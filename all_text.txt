





Version control - Bubble Docs









Bubble DocsSearch⌃KBubble DocsSearch⌃KIntroductionNew? Start HereChangelogUser manualDesignDataLogicMaintenanceVersion controlBest practices: Version controlTransitioning from the legacy version controlTerminology: Version controlVersion Control (legacy)Database maintenancePerformance and ScalingSEOTesting and DebuggingAPI Workflow SchedulerCollaboratorsCommentingIntegrationsInfrastructure/complianceCustomizing an ApplicationMore about Bubble appsCore ReferenceBubble's InterfaceElementsWorkflowsEventsDataStylesAPIBubble-made PluginsApplication SettingsActionsAccount & MarketplaceAccount & BillingDedicated PlansBuilding PluginsBuilding TemplatesMiscellaneousThe ShowcaseMore features for your to-do appThe GlossaryPre-releaseAlpha: Bubble Plugin APIPowered By GitBookVersion controlThis section covers the version control system.IntroductionThe version control system introduces some new terminology. You may find our dedicated article on version control terminology useful while you are reading this article. Article: Version control terminology​​If you are used to our legacy version control system, we also recommend reading our transitioning guide:
Article: Transitioning from the legacy version control​This is the long-form article on how Bubble's version control system works. For the short-form technical reference that lists all of version control's features, see this link:Reference: Version control​Other ways to learn: Video (10)We are also covering this subject with short-form video lessons.​YouTube playlist​1.​What is version control?​2.​Interface overview​3.​Creating savepoints​4.​Deploying to live​5.​Creating custom branches​6.​Merging custom branches​7.​Resolving conflicts​8.​Syncing custom branches​9.​Deleting custom branches​10.​Using the hotfix branch​Join our Youtube communityFor more video lessons, check out our Youtube channel.By default, your application consists of two separate environments: Development and Live. They exist in parallel so that you can keep developing the application without the live app changing. When changes in the Development environment are completed, you can push them to Live by deploying.Bubble automatically generates two environments in your app – one for Development and one for Live.The two environments are completely separate with two independent databases. The Live branch is read-only, while the Development branches are all editable. After you deploy your app and have active users, the Development environment allows you to build and test new features, maintain your app, and test it without disturbing your users. As your app starts to scale, it's important to keep track of all the changes and updates you make from there on. Perhaps you need to work on several bigger updates at once, such as two or more major new features being developed by separate teams. Bubble's version control system lets you divide the development of your project into independent parts, so that you and other editors with access to the project can iterate on one part of the app without impacting other parts. This helps you simultaneously progress multiple streams of work and stay on top of the changes made as each goes from development to testing to deployment.Basic version control features are available on any Bubble app subscribed to a paid plan, with the full suite of capabilities unlocked on the higher-tier plans.See and compare the different Bubble plans here and the version control feature set here.Environments and branchesEnvironmentsAll deployed Bubble application consist of two different environments:The Development environment allows you to develop and preview your app exactly as it will look when deployed. When testing changes in a branch in the Development environment, the Development database will get populated with test data, which you can view by going to the Data tab and toggling to the Development database. The Live environment contains your live app, which is read-only. When users interact with your live app, the Live database will get populated with live data, which you can view by going to the Data tab and toggling to the Live database by clicking Switch to Live database.The Development and Live environments have separate databases.These two environments give you a safe and predictable way to continue development on your app, knowing that your live users will not notice any changes to the app or their data unless you specifically deploy those changes to Live.BranchesA branch is an independent iteration of your application that can be developed in isolation. You can see the creation of a branch as splitting your app into two copies, kind of like two cells dividing. The cells are genetically identical clones at first, but can keep evolving independently of each other. In each of the two environments (Development and Live), a new branch is automatically set up:The Live branch is the read-only, public branch of your app. It is part of the Live environment along with the Live database.The Main branch is where your app is developed and tested before being deployed. The Main branch exists in the Development environment. This is the Basic version control setup, which is often sufficient for projects with a solo developer or smaller updates. It gives you full control over what your end-users experience. Premium version control evolves the relationship between your two primary branches Main and Live. With Premium, you’ll unlock a variety of advanced branching capabilities that can empower you and your team with new ways to tackle and organize your project. For example, with Premium comes the ability to create custom branches off of Main, to merge or sync branches as needed, and to create a special hotfix branch off of Live.See the table below for more info on which app plans offer Basic vs. Premium version control.What's the difference between an environment and a branch?To make the terminology clear, let's list the main differences: EnvironmentsThere are only ever two environments: Development and Live Environments have separate databases You cannot create or delete environmentsBranches Branches exist in an environment There can only ever be one Live branch, but there can be multiple Development branches The Live branch has a database to itself, while all branches in the Development environment share one database On higher-tier plans you also have a hotfix branch that branches off Live but uses the development databaseAccessing the version control systemYou can open the version control panel by clicking on the branch icon near the top right, which shows the name of the current branch:The Main branch is automatically createdCustom branchesWith Basic version control, the Main branch is the only Development branch, so it is the only one you can make changes to; you build and test changes in the Main branch before deploying those changes to Live. On higher-tier plans, you have access to Premium version control, which allows you to create custom branches to work on specific parts of the app in isolation. The total number of custom branches available depends on your app plan.With the ability to create custom branches, we should think about Main differently. Before, Main was the only branch in which you could make changes, so you would edit and deploy all from the same branch. Now that you have the ability to create custom branches for your work, Main should be preserved solely for deployment.In general, preserving your upper-most branch for deployment is best practice for keeping your project organized. For any new change or feature you wish to explore, you can create custom branches for each effort. The deeper down this hierarchy of custom branches you go, the more focused your building and testing becomes. And as you conclude your testing, you merge your changes back up the hierarchy until all the changes you want are integrated in Main and ready for deployment.Think of the Main branch’s new role as a launching pad. By the time the rocket reaches this point, it should just be ready to fly.Branch name and unique IDWhen you create a new branch, the name you provide will be used as a label in the version control dashboard. Bubble also generates a unique ID for the branch.Note that:The name and unique ID of the branch are independent of each other and may not matchThe unique ID is permanent and will not be re-used even if you delete a branchThe unique ID is visible in the URL when you preview your app after “version-[ID] and in the URL of the Bubble editor after “version=[ID]”If you want to reference a specific branch by its URL, use the branch ID Creating a custom branch Branches are organized in a tree-like structure, where branches form parent-child relationships. The first custom branch you create will clone the Main branch and become its child. In the example above the new-feature branch is a child of the Main branch.You can then continue to develop that child branch and see the two versions become different as they evolve in different directions.Branches can stem off of other branches, creating parent-child relationships as many layers deep as you need. This gives a high degree of control over the development of your app as you can isolate every part of a project as you see fit.Merging branchesMerging branches allows you to add the changes you’ve made from one branch of your app to another. You can merge the changes from a child branch into a parent branch, from a parent branch into a child branch or from one sibling branch to another. Regardless of where you are in your hierarchy, merging takes changes created in one branch (the source branch) and integrates them into the other branch (the base branch).It’s a powerful feature that ultimately saves you the hassle of copying and pasting every little change from one branch into another. And Bubble provides an intuitive step-by-step flow that walks you through the entire merge process.Let’s look at an example where we merge the changes from a child to a parent branch:Step 1: Select branchesBefore starting a merge, navigate to your base branch. Then, when you start a merge, the first step of the merge flow is to select the source branch that contains the changes you want to integrate. Bubble will create an automatic savepoint in the base branch before and after the merge is performed.Step 2: Review changesThe next step after you have selected which branches to merge is to preview and confirm the non-conflict-generating changes that will be  made. Bubble will list these changes grouped by page: In our example, we are merging changes from a branch called pricing-change, and Bubble notifies us that a change has been made. Clicking on the change will take you directly to the parameter that has changed (except if the relevant element or workflow has been deleted):By clicking on the change, Bubble takes you directly to the place where the change happened. This way you can review any non-conflict-generating changes between the two branches to stay on top of what your team has done, and confirm these changes before moving on to conflict resolution.Step 3: Resolve conflictsSometimes, a change is made to an element or workflow in one branch, and the same element or workflow is changed differently in another branch. Let's say we have set up a child branch of pricing-page called button-design, and we're experimenting with different button styles. 1. In the base branch (button-design), the button has the color #0018CC (blue)2. In the source branch (pricing-page), the button has the color #229A44 (green)If we want to merge branch 1 and branch 2, it would seem we have a conflict: which color should the button have? Bubble recognizes conflicts like these and presents them to you in a list grouped by page . The left-hand column shows the base branch, and the right-hand column shows the source branch. Each row has a checkbox that allows you to review what the change looks like in each branch. In the animation below, you can see that by checking the boxes in each branch, you can review the conflicting changes.Reviewing conflicting changes in each version is easy and you can select which change you prefer to keep.If you check the box next to the branch itself you can automatically toggle all conflicts on that page to one branch. If you want to approve changes one-by-one you can use the checkboxes on each row. Each page in the list is collapsable.After this, the merge is ready to be finalized. Click the Confirm X choice and merge button. You will be asked a final time to confirm that you want to go ahead with the merge before Bubble initiates it. The merge can easily be undone using the cancel and exit merge button.Syncing from the Live and Main branchIf you have multiple teams working in different branches of your app, there can be instances where the Live branch is updated while some of the branches in the Development environment are still in development. This will also be the case when you deploy a hotfix branch to Live.In those cases it's best practice to merge the changes from the Live branch to the branch you are working in, to make sure that it's consistent with the live app. In the example above you'll see that Bubble gives you a warning that the current branch is out of sync with Live, and you can click the Sync button to update the branch you are currently working on.The hotfix branchThe hotfix branch is the only branch apart from Main that can be deployed directly to Live. The purpose of this branch, as the name suggests, is to address urgent issues that can be fixed quickly. For example, let's you discover that the Submit button on an important customer contact form is not working and you need to fix it immediately, you can set up a hotfix branch, make the necessary change and deploy to live immediately.This is useful since Main can sometimes contain changes that you're not ready to publish yet.The hotfix branch has the following properties:You can only ever have one hotfix branch, and it only exists when you create oneThe hotfix branch is connected to the development databaseYou can access other branches while a hotfix branch exists, but you cannot deploy from the Main branchWhen you merge from the hotfix branch to the Live branch, the hotfix branch is deletedCreating a hotfix branchTo create a hotfix branch, followe the instructions below:1.1. First, navigate to the Live environment 2. Click Create a hotfixDeploying the hotfixOnce you’ve made the necessary changes to your app, you'll be ready to deploy the hotfix branch to Live. To initiate this process, click on the 'Deploy to Live' button.

The hotfix branch is displayed as a child to the Live branch.It's important to note that deploying a hotfix branch will cause any Development branches to become out of sync with Live. To ensure that everything is up to date, we recommend syncing any development branches with Live after the hotfix branch has been successfully deployed.Deleting branchesWhen branches are no longer needed, they can be deleted. This includes the hotfix branch if you want to remove it without deploying the changes to Live. We recommend that branches are short-lived and contain a minimal number of changes. Branches should be created, merged, and deleted with regular frequencyTo delete it, follow the steps below:1. Activate the branch you want to delete 2. Click the dropdown menu next to the branch name 3. Click delete and confirmSavepointsIn any branch, you can create savepoints that create a snapshot of that branch at that specific point in time. A savepoint is created automatically when you: deploy to Live start a merge finish a merge cancel a mergeimport a branch over anotherright before you restore your branch You can also create as many custom savepoints as you need in case you need to roll back changes you made in a specific branch. 
To create a savepoint, open up the branch where you want to save it, click the History tab and then Create a savepoint. It’s also accessible in the top right corner menu of the branch panel. You will be asked to add a description to it, and we recommend providing some information about why it was created. Reset branch to LiveYou can also reset a branch to Live. This will replace everything in the branch with a clone of the Live branch. This is useful if you need to start over on a branch but you have made changes to Main that you’re not ready to create a new branch from.Restore branchA branch can be restored to a savepoint at any time if you need to revert your work. Savepoints are created automatically at given points, but you can also create as many manual savepoints as needed and restore the branch to that state. To restore a branch:Go to the History tab in the version control panelCheck the radio box with the savepoint you want to restoreClick Restore to this savepointWhile the version control system takes care of all of the underlying mechanics of creating and managing different branches of your app, the structure in which you plan and carry this out is up to you as the app owner. While you are free to set it up as you please, we have compiled a document which recommends best practices, especially for bigger teams:Article: Version control best practices​More ways to learnVersion control video lessonsWe also have a list of video lessons that take you through version control. You can also visit and subscribe to our Youtube channel for more lessons:Video lessons: Version controlVersion control core referenceFor the short-form technical reference that lists all of version control's features, see this link:Reference: Version control​Legacy documentationFor the documentation on the legacy version control system, check out the resources below:Article: Version Control Manual (legacy)
Reference: Version control (legacy)​User manual - PreviousMaintenanceNextBest practices: Version controlLast modified 1mo agoCopy linkOn this pageIntroductionEnvironments and branchesEnvironmentsBranchesWhat's the difference between an environment and a branch?Accessing the version control systemCustom branchesBranch name and unique IDCreating a custom branch Merging branchesStep 1: Select branchesStep 2: Review changesStep 3: Resolve conflictsSyncing from the Live and Main branchThe hotfix branchCreating a hotfix branchDeploying the hotfixDeleting branchesSavepointsReset branch to LiveRestore branchMore ways to learn










Best practices: Version control - Bubble Docs









Bubble DocsSearch⌃KBubble DocsSearch⌃KIntroductionNew? Start HereChangelogUser manualDesignDataLogicMaintenanceVersion controlBest practices: Version controlTransitioning from the legacy version controlTerminology: Version controlVersion Control (legacy)Database maintenancePerformance and ScalingSEOTesting and DebuggingAPI Workflow SchedulerCollaboratorsCommentingIntegrationsInfrastructure/complianceCustomizing an ApplicationMore about Bubble appsCore ReferenceBubble's InterfaceElementsWorkflowsEventsDataStylesAPIBubble-made PluginsApplication SettingsActionsAccount & MarketplaceAccount & BillingDedicated PlansBuilding PluginsBuilding TemplatesMiscellaneousThe ShowcaseMore features for your to-do appThe GlossaryPre-releaseAlpha: Bubble Plugin APIPowered By GitBookBest practices: Version controlThis section covers best practices for using the version control feature with one or more teamsUse the Main branch as a launching padYour Main branch is the only branch you can deploy to Live (except for the hotfix branch) and you should keep this in mind as you organize Main's child branches. What this means is that changes and experimentation should always be completed in full in a child branch and then merged up through the hierarchy until it reaches the Main branch. At that point it should be safe to delete the child branches and there should be no development work done in the Main branch. This means that the Main branch should always be the "polished" last branch of your app that's ready to be deployed. Merge changes from parent to child first Whenever you want to merge changes from a child branch to a parent branch, we recommend that you first merge changes from the parent branch into the child branch. This is because it's lower risk to test that everything works well in the child branch before you then merge the changes up the hierarchy into the parent branch. The same holds true when you are merging a custom branch into the Main branch. Use the Sync with Main shortcut to add all changes from Main into the custom branch first.In other words: 1.First merge the changes from the parent to the child 2.Do the necessary testing in the child branch 3.Then merge the changes from the child to the parent Keep the branch tree clean and organized Whenever a branch has served its purpose (the development is done and the changes have been merged up the hierarchy) you should delete the branch to keep your branch tree updated. Keeping around unnecessary branches makes the tree disorganized and it's easy to lose sight of why the branch was created in the first place, whether it has been merged upward already and whether it's safe to delete. You can always create a new branch as needed, so there's no need to keep around the old ones.PreviousVersion controlNextTransitioning from the legacy version controlLast modified 1mo agoCopy linkOn this pageUse the Main branch as a launching padMerge changes from parent to child first Keep the branch tree clean and organized 










Transitioning from the legacy version control - Bubble Docs









Bubble DocsSearch⌃KBubble DocsSearch⌃KIntroductionNew? Start HereChangelogUser manualDesignDataLogicMaintenanceVersion controlBest practices: Version controlTransitioning from the legacy version controlTerminology: Version controlVersion Control (legacy)Database maintenancePerformance and ScalingSEOTesting and DebuggingAPI Workflow SchedulerCollaboratorsCommentingIntegrationsInfrastructure/complianceCustomizing an ApplicationMore about Bubble appsCore ReferenceBubble's InterfaceElementsWorkflowsEventsDataStylesAPIBubble-made PluginsApplication SettingsActionsAccount & MarketplaceAccount & BillingDedicated PlansBuilding PluginsBuilding TemplatesMiscellaneousThe ShowcaseMore features for your to-do appThe GlossaryPre-releaseAlpha: Bubble Plugin APIPowered By GitBookTransitioning from the legacy version controlThis section includes tips for transitioning from the legacy to the new version control systemThe new version control system introduces new terminology. We have compiled a list of the terminology of the new system, as well as the terms that are no longer used:Article: Version control terminology​The transition process described below is only relevant to existing apps with multiple development versions. If version-test is your only development version, your app will automatically be upgraded to the new version control system, and version-test will become the Main branchThe legacy version control system had a linear approach to managing application changes, allowing separate versions to be created and worked on in isolation. However, this method had its limitations, especially when it came to collaboration and managing the development of major new features.The new branch-based system offers a more flexible, powerful, and collaborative approach to managing app development.This article guide will give you an overview of how to transition from the old Bubble version control system to the new system. Throughout the guide, we will discuss key concepts, such as branches, merging, and managing conflicts, and provide step-by-step instructions to help you get started with the new system.Upgrading to the new version controlIf you have at least one custom version in the legacy version control system, you will be asked to opt-in to the new system.Note: The upgrade to the new version control system is permanent and cannot be undone.You will find the button to upgrade when you click the current version control menu bar link in the upper right corner of the Bubble editor:General adviceVersions are now branchesA key aspect of  the new version control system is that what used to be called versions are now called branches. This new terminology better describes how the system works, as we have moved away from the linear systems of separate versions into a parent-child based "tree" of branches that can be added and removed as needed.This helps you work not only on new features, but it allows you to further separate development on those features into child branches that can later be merged upwards into the parent. No data or ongoing work will be deleted when you make the transitionBefore we dive into the process of transitioning to the new branch-based system, it's important to clarify that the new system is compatible with any existing versions you have. In other words, you will not lose your versions when you choose to activate the new version control system.It may still be useful to clean out your versions ahead of upgrading and to get to know our recommended best practices. This helps you get a clean start and set up a structure that makes sense for your team.Transition scenariosWe’ll now cover two different scenarios that require slightly different steps to getting up and running smoothly.Scenario 1: Your app is on an Agency Plan, Professional Plan, Production Plan, or Dedicated Plan and your last deploy to Live was made from version-testWhen you turn on new version control, you’ll notice the brand new UX and that version-test is now the Main branch.Any custom versions you created previously will show up below the Main branch.Any in-progress work remains undisturbedThe new Main branch (formerly the development version or version-test) is the only branch that can be deployed to Live. The hotfix branch can also be deployed, but they are meant for quick bug only fixes in the Live environment and block other development work until the hotfix is deployed or deleted.If your last deploy to Live was made in the development version (a.k.a. version-test), and no changes were made in development since that deploy, you should be able to proceed as usual as your Main branch is up to date with Live.If your last deploy to Live was made in version-test, and there is in-progress work since the last deploy that you want to save, create a new branch off of Main.This new branch will be a mirror image of the old development version. You can then reset your Main branch to match Live by using the “Reset to Live” feature in the More actions dropdown in the top right of the version control panel. This will ensure that Main is a carbon copy of the Live branch so that any future deploys will proceed smoothly. Then, when you are ready, you can merge any changes into Main and deploy those changes to Live.Scenario 2: Your app is on an Agency Plan, Professional Plan, Production Plan, or Dedicated Plan and Your last deploy to Live was made from a custom versionWhen you turn on new version control, you’ll notice the brand new UX and your development version will automatically turn into the Main branch. Any custom versions you created previously will show up as branches below the Main branch.Any in progress work remains undisturbedThe Main branch is the only branch that can be deployed to Live. Hotfix branches can also be deployed, but they are meant for quick bug fixes in the Live environment and block other development work until the hotfix is deployed or deletedIf your last deploy was made in a custom version, there is a good chance that version-test does not have the same changes that Live has - which will be required to deploy anything to Live in the future. Since version-test is now Main, and Main is the only branch that can be deployed to Live, you’ll want to move some things around to adjust to this new flow.If there is any in-progress work in version-test (now Main) that you want to save, create a new branch off of Main. This new branch will be a mirror image of the old development version.Navigate to the Main branch and reset the Main branch to match Live by using the “Reset to Live” feature in the More actions dropdown in the top right of the version control panel. This will ensure that Main is a carbon copy of the Live branch so that any future deploys will proceed smoothly.For any work in a custom branch that is ready to be deployed, first sync that custom branch with Main (using the button in that branch’s version control panel) to make sure that branch is up to date with Main/Live and then merge that branch into Main. When the branch has been merged, you can deploy Main to Live.For any new work, create a custom branch off of Main and use that new branch for any development work. When you are ready to merge that work and deploy to live, sync that custom branch with Main (using the button in that branch’s version control panel) to make sure that branch is up to date with Main/Live and then merge that branch into Main. When the branch has been merged, you can deploy Main to Live.Good luck with the transition! To further get to know the new version control system, we recommend reading our introductory article and study the new terminology.Article: Version control​Article: Version control terminology (direct link: legacy terms that have been updated)Article: Legacy version control documentation​PreviousBest practices: Version controlNextTerminology: Version controlLast modified 1mo agoCopy linkOn this pageUpgrading to the new version controlGeneral adviceVersions are now branchesNo data or ongoing work will be deleted when you make the transitionTransition scenariosScenario 1: Your app is on an Agency Plan, Professional Plan, Production Plan, or Dedicated Plan and your last deploy to Live was made from version-testScenario 2: Your app is on an Agency Plan, Professional Plan, Production Plan, or Dedicated Plan and Your last deploy to Live was made from a custom version










Terminology: Version control - Bubble Docs









Bubble DocsSearch⌃KBubble DocsSearch⌃KIntroductionNew? Start HereChangelogUser manualDesignDataLogicMaintenanceVersion controlBest practices: Version controlTransitioning from the legacy version controlTerminology: Version controlVersion Control (legacy)Database maintenancePerformance and ScalingSEOTesting and DebuggingAPI Workflow SchedulerCollaboratorsCommentingIntegrationsInfrastructure/complianceCustomizing an ApplicationMore about Bubble appsCore ReferenceBubble's InterfaceElementsWorkflowsEventsDataStylesAPIBubble-made PluginsApplication SettingsActionsAccount & MarketplaceAccount & BillingDedicated PlansBuilding PluginsBuilding TemplatesMiscellaneousThe ShowcaseMore features for your to-do appThe GlossaryPre-releaseAlpha: Bubble Plugin APIPowered By GitBookTerminology: Version controlThis section contains terminology related to the version control systemThis page contains short descriptions of the version control terminology. For a more comprehensive guide on version control works or the core reference of all the available features, see the links below:Article: Version control​Reference: Version control​The terminology used by Bubble's version control system may not be immediately apparent or easy to grasp at first. This article contains a list of the different terms used and may be helpful as you get to know how the system works.At the bottom of the page you will find terminology that has changed from the legacy system.TerminologyTermDefinitionbase branchThe branch that you want to merge changes intobranch treeThe visualization that shows you where a branch came from and how it relates to other brancheschild branchA branch that has a parent branch; a child branch can also be a parent branchconflictConflicts arise during the merge process when the base branch and the source branch each changed the same thing (in different ways) since the last time the two branches were in syncconflict resolutionConflict resolution is the process of resolving conflicts. The conflict resolution window organizes conflicts by page and gives you the option to resolve all conflicts in favor of one branch on a page-by-page basis.custom branchApps on the higher plans can have one or more custom branchesdeploy, deploymentTo deploy a branch is to push changes to Live. Only the Main branch and the hotfix branches can be deployed to Live.Development environmentThe development environment contains Main, any custom branches, and hotfix branchenvironmentEnvironments contain branches. There are two environments: live and development. The environment is defined by the database that it uses (i.e., the live environment uses the live database, while the development environment uses the development database).hotfix branchThe hotfix branch is the only branch that can branch off of Live. Only one hotfix branch can exist at a time. While a hotfix branch exists, Main cannot be deployed to Live. Hotfix is available on higher plans.in syncWhen two branches are in sync, there are no conflicts that would be generated from merging the two branchesLiveLive is the version of your app that lives on the internet for users to interact withLive environmentThe live environment contains LiveMain branchAll apps have a Main branch. Main is the only branch that can be deployed to Live (aside from hotfix). Main sits at the very top of the branch tree hierarcmerge, mergingThe process of integrating changes from the source branch into the base branchparent branchA branch that has child branches branching off of it; a parent branch can also be a child branchresolve conflictsTo resolve conflicts that arise during the merge process, you must select which change to favorrestoreTo restore is to return to a past version of a branch by using the savepoint feature or by entering a custom date/timesavepointSavepoints are automatically created in the base branch when you deploy to Live, start a merge, finish a merge, cancel a merge, or right before you restore your branch.
Custom savepoints are savepoints that you can manually create at any time.savepoint retention windowAn app’s savepoint retention window dictates how far back you can restore any one of your branchessource branchRefers to the branch that is the source of changes that you want to merge into the base branchsyncTo sync two branches is to merge them for the purposes of bringing changes in Live or Main into the base branchto branch, branchingTo create a branch off of another branchversion controlThe system for tracking and managing changes to your app.Legacy terminology and replacementsIf you have been using Bubble for some time you may be familiar with the existing terminology that surrounded the previous version control. The following terms have been removed or replacedTermDefinitionAdding changes from one version to anotherNow "merging"DevelopmentNow "Main branch"live versionNow "Live"custom versionNow "custom branch"​PreviousTransitioning from the legacy version controlNextVersion Control (legacy)Last modified 1mo agoCopy linkOn this pageTerminologyLegacy terminology and replacements










Database maintenance - Bubble Docs









Bubble DocsSearch⌃KBubble DocsSearch⌃KIntroductionNew? Start HereChangelogUser manualDesignDataLogicMaintenanceVersion controlDatabase maintenanceCopying the databaseRestoring database backupsBulk OperationsPerformance and ScalingSEOTesting and DebuggingAPI Workflow SchedulerCollaboratorsCommentingIntegrationsInfrastructure/complianceCustomizing an ApplicationMore about Bubble appsCore ReferenceBubble's InterfaceElementsWorkflowsEventsDataStylesAPIBubble-made PluginsApplication SettingsActionsAccount & MarketplaceAccount & BillingDedicated PlansBuilding PluginsBuilding TemplatesMiscellaneousThe ShowcaseMore features for your to-do appThe GlossaryPre-releaseAlpha: Bubble Plugin APIPowered By GitBookDatabase maintenanceThis section covers copying, restoring and running bulk operations on the databaseThis section covers different ways in which you can maintain your database to keep it running efficiently. If you want to learn more about the database in general and how it works, you can check out our dedicated article series below.Article series: The database​The database is the filing cabinet of your application, where all data is archived for storage. Just like a regular archive, it makes sense to keep it clean and up-to-date.This is a good idea for a few reasons:The more unnecessary data you keep around, the bigger your database becomes. This means more data for Bubble to search through and overall can affect your performanceRemoving unneeded data is good from a privacy perspectiveAs you scale and grow your app, a clean database can help you with decision making, since you can confidently make decisions based on reliable dataThis article series goes over a few different concepts that helps you maintain your database properly.Copying the databaseCopying the database means to clone the content of the development database into the live database or vice versa. This is a simple, automated operation in Bubble.Article: Copying the databaseRestoring database backupsBubble keeps automated point-in-time backups that can be restored back to that state with a simple operation.Article: Restoring database backups​Running bulk operationsBulk operations means to run a workflow on multiple things in your database in sequence. This helps you perform tasks that would be tedious to do manually, such as deleting and making changes to things.Article: Bulk operations​​PreviousVersion Control (legacy)NextCopying the databaseLast modified 14d agoCopy link










Copying the database - Bubble Docs









Bubble DocsSearch⌃KBubble DocsSearch⌃KIntroductionNew? Start HereChangelogUser manualDesignDataLogicMaintenanceVersion controlDatabase maintenanceCopying the databaseRestoring database backupsBulk OperationsPerformance and ScalingSEOTesting and DebuggingAPI Workflow SchedulerCollaboratorsCommentingIntegrationsInfrastructure/complianceCustomizing an ApplicationMore about Bubble appsCore ReferenceBubble's InterfaceElementsWorkflowsEventsDataStylesAPIBubble-made PluginsApplication SettingsActionsAccount & MarketplaceAccount & BillingDedicated PlansBuilding PluginsBuilding TemplatesMiscellaneousThe ShowcaseMore features for your to-do appThe GlossaryPre-releaseAlpha: Bubble Plugin APIPowered By GitBookCopying the databaseThis section covers how to copy the content of the Development database to the Live database, and vice versaCopying between the Live and Development databasesThis option lets you overwrite the entire database, or only a selected data type, from Development to Live and vice versa. Note that the operation can take some time to finish if you have a large database.To start the process, navigate to the Data tab and then click the Copy and restore database link.Bubble will open a popup that shows you the different options.Click the image to enlarge.You will see two buttons:Copy Live data into the Development databaseCopy Development data into the Live databaseTo start the process, click one of the buttons.Click the image to enlarge.1.In this example, we want to copy data from Live into Development, so we click the left button2.Data types to copy lets you select all types or select one type*3.As an extra security measure to avoid accidental overwriting of data, we ask that you spell out a short sentence to confirm that you want to proceed4.Finally, you can press the Confirm button to start the operation. For large database where you copy all content, the process can take some time to finishKeep in mind when copying Live data into Development that this can give your Collaborators access to more data than you intended. Always be mindful of the privacy of your users when you copy data.*Be cautious when you copy only one data type, as it can lead to data inconsistencies if some things are related. Sometimes it's better to still restore all to make sure that no relationships are lost.PreviousDatabase maintenanceNextRestoring database backupsLast modified 1mo agoCopy link










Restoring database backups - Bubble Docs









Bubble DocsSearch⌃KBubble DocsSearch⌃KIntroductionNew? Start HereChangelogUser manualDesignDataLogicMaintenanceVersion controlDatabase maintenanceCopying the databaseRestoring database backupsBulk OperationsPerformance and ScalingSEOTesting and DebuggingAPI Workflow SchedulerCollaboratorsCommentingIntegrationsInfrastructure/complianceCustomizing an ApplicationMore about Bubble appsCore ReferenceBubble's InterfaceElementsWorkflowsEventsDataStylesAPIBubble-made PluginsApplication SettingsActionsAccount & MarketplaceAccount & BillingDedicated PlansBuilding PluginsBuilding TemplatesMiscellaneousThe ShowcaseMore features for your to-do appThe GlossaryPre-releaseAlpha: Bubble Plugin APIPowered By GitBookRestoring database backupsThis section covers how you can copy the contents of your database, as well as restore it to a snapshot of what it looked like at a specific date and timeThe actions described below can potentially rewrite all the contents of your database. Be careful when using these features, and double-check that your settings are correct before you go ahead. Copying and restoring large databases can take some time to finish.Restoring your databasePoint-in-time backupsBubble uses a system called point-in-time backup, which means that for every change made to the database, a snapshot is saved. This snapshot can then be used later to restore the database to that exact point in time if something should go wrong. This is particularly useful for recovering data in the case of accidental deletion or changes.Bubble backs up all your data types continuously, but you can choose to recover only specific data types.How far back in time you can recover your database depends on the Plan that you are on.Restoring your data is done in the App Data section of the Data tab. First, navigate to the Data tab, and click the Copy and restore database link:Bubble will open a popup that shows you the different options.You first pick the version you want to restore (Development or Live), then a time and confirm. You can choose to restore all data types or only one.Be cautious when you restore only one data type, as it can lead to data inconsistencies if some things are related. Sometimes it's better to still restore all to make sure that no relationships are lost.You can set the time of the restoration down to the second, meaning that if you know the exact time that someting went wrong, you can restore it to just a few seconds before the incident Restore operations can take a few minutes to execute if your database is large.You'll see a progress bar once you have started the process, and can close the popup and keep working on your app. It is safe to refresh the editor or close it once you have kicked off the process.​PreviousCopying the databaseNextBulk OperationsLast modified 1mo agoCopy linkOn this pageRestoring your databasePoint-in-time backups










Bulk Operations - Bubble Docs









Bubble DocsSearch⌃KBubble DocsSearch⌃KIntroductionNew? Start HereChangelogUser manualDesignDataLogicMaintenanceVersion controlDatabase maintenanceCopying the databaseRestoring database backupsBulk OperationsPerformance and ScalingSEOTesting and DebuggingAPI Workflow SchedulerCollaboratorsCommentingIntegrationsInfrastructure/complianceCustomizing an ApplicationMore about Bubble appsCore ReferenceBubble's InterfaceElementsWorkflowsEventsDataStylesAPIBubble-made PluginsApplication SettingsActionsAccount & MarketplaceAccount & BillingDedicated PlansBuilding PluginsBuilding TemplatesMiscellaneousThe ShowcaseMore features for your to-do appThe GlossaryPre-releaseAlpha: Bubble Plugin APIPowered By GitBookBulk OperationsThis section covers bulk operations, which lets you run API Workflows on a list of things directly from the Bubble database editorBulk operations let you execute workflows on a large set of data within the Editor. By scheduling a pre-defined API Workflow on the provided list, you can perform the same wide array of actions on a list of things that you can do in your app.Note: Bulk operations run client-side, so they depend on your browser window staying open and active. In other words, you need to keep the popup open for them to continue. If you are looking to modify a large amount of data, the most effective and reliable solution is to use recursive scheduled workflows instead.Defining an API workflowBefore you can perform bulk workflows on your data, you need to define the API Workflows that you are going to call.If you are not familiar with Bubble's Workflow API and how to set up API Workflows, we recommend you first get to know how they work. The first link below gives an introductory guide to the Workflow API in general, and the second shows you how to set up API Workflows that can be used with bulk operations.Article: The Workflow API​Article API Workflows​Valid API Workflow parametersTo be valid for scheduling by the Bulk operation feature, API Workflows must have a few properties in place:A thing parameter: the workflow must include a parameter that requires a 'thing' of the same data type as the one you intend to perform the bulk operation onThe API Workflow must have a parameter that lets you specify a thing to run the workflow on. In the example above we're instructing Bubble to request a thing of the type Product.Only set up one parameter: when a bulk operation is called, Bubble will only fill one parameter: the thing it's currently scheduling the operation on. In other words, do not set up any other parameters.The thing cannot be a list: bulk operations are scheduled one-by-one on a list of things. In other words, the parameter that asks for which thing to perform the operation on should ask for a single think, not a list/array.It does not need to be exposed as a public API Workflow: while it will still work if you expose it, it's better to uncheck the Expose as a public API Workflow checkbox to make sure that it cannot be triggered from outside of your app.Adding actionsNow we have an API Workflow that accepts a single parameter: the thing that we want to run the operation on. In our example we set that thing to a custom data type called Product, so let's make a change to that thing. We have a  yes/no field on the product called Published that we want to set to yes.In our API Workflow, this is a very simple Make changes to a thing operation:1.First, we add the Make changes to a thing action to the API Workflow2.Then, we choose product as the thing we want to change. This is the parameter we set up earlier.3.Finally, we set the Published field on the product to yesRunning the bulk operationNow that we have the workflow we want to run the bulk operation on, let's see how we trigger it to run.1.First, we select the data type that we want to run the bulk operation on. In this case, we want to work with Products2.Next, select the Products that you want to run the operation on. Trucker cap and Baseball cap are ready to be published, but Product 1 still needs some work, so let's just check to two top ones.3.Then, we click the Bulk button, where we'll select with API Workflow to run on the selected things.Keep in mind that bulk operations spend your app's server capacity just like every other operation. If you run bulk operations on thousands of entries, they can take some time to finish, and can use a noticeable chunk of your capacity.Bulk operations typically make changes to a list of records. If you make a mistake when running a bulk operation, you can restore the data type to what it looked like before the operation by using the Copy and restore database feature.Click the image to enlarge.1.In the first dropdown, we choose what list to run the operation on. You can choose to run it on the entire current view, or the selected entries – in our case we specifically selected two entries, to let's go with that2.In the second dropdown you will find the list of compatible API Workflows. If the Workflow does not accept the same data type as a parameter, it will not be selectable3.The text next to point three confirms that the workflow will in this case be run on 2 entries, which is what we selected4.Finally, we can click Run workflow and the operation will start. Since we are only making a small change on two entries, it should finish very quickly.Looking again at the data in our database, we can see that the two data types we selected now have their Published field set to yes.Click the image to enlarge.Combining bulk operations with viewsViews let you filter the data displayed in the database editor by specific constraints, just like the Do a search for data source. Since bulk operations let you run the operation on all records in the current view, you can combine these features to flexibly run bulk operations on things that match specific criteria, instead of manually selecting the things in the list.To set up a new view, click the New view button or the pencil icon next to the data type you want to run an operation on.Additional resourcesRecursive Workflows - used to process large amounts of dataFor bulk operations on larger record sets, consider using the recursive workflow method. Recursive workflows are API Workflows that schedule just one task at a time, rescheduling themselves upon completion. This method allows operations on a list of things while providing greater control over capacity usage. By spacing out workflows, you can reduce the overall server capacity spent by that operation.Note that recursive workflows must be triggered from your app, not using the Bulk feature.Article: Recursive workflows​Schedule API Workflow on a list – used to trigger bulk operations in your appThe Bulk feature is triggered from inside the Bubble editor, but technically does the same thing as the Schedule API Workflow on a list feature. To run bulk operations in your app instead, use that action to trigger the workflow.Reference: Schedule API Workflow on a list​​​PreviousRestoring database backupsNextPerformance and ScalingLast modified 28d agoCopy linkOn this pageDefining an API workflowValid API Workflow parametersAdding actionsRunning the bulk operationCombining bulk operations with viewsAdditional resources










Performance and Scaling - Bubble Docs









Bubble DocsSearch⌃KBubble DocsSearch⌃KIntroductionNew? Start HereChangelogUser manualDesignDataLogicMaintenanceVersion controlDatabase maintenancePerformance and ScalingHard limitsCapacity Usage (legacy)Notes on QueriesSEOTesting and DebuggingAPI Workflow SchedulerCollaboratorsCommentingIntegrationsInfrastructure/complianceCustomizing an ApplicationMore about Bubble appsCore ReferenceBubble's InterfaceElementsWorkflowsEventsDataStylesAPIBubble-made PluginsApplication SettingsActionsAccount & MarketplaceAccount & BillingDedicated PlansBuilding PluginsBuilding TemplatesMiscellaneousThe ShowcaseMore features for your to-do appThe GlossaryPre-releaseAlpha: Bubble Plugin APIPowered By GitBookPerformance and ScalingThe Bubble team is constantly looking to optimize scalability and performance. This means improvements to both the Bubble platform to handle all the thousands of Bubble apps (our scalability and performance), as well as to the platform so that Bubble apps provide a good experience for their end-users.Performance and scaling of a Bubble app are heavily impacted by how the app is built. This page will give an overview of app performance and scalability as well as offer some concrete tips.General principles & tips about performanceThe less data being fetched, the faster the performance - a page often needs to fetch some data on page load; a page that fetches 100 things on page load will load faster than a page that fetches 1 million data items; similarly, fetching simple data types like numbers will be faster than fetching MBs of dataSimilarly, having many small, simple pages will be faster than having fewer, complex pagesKeep any sorting or filtering as close to the original search as possible - Bubble already optimizes database queries in many ways, but performing a sort or filter at the database level is very efficient. This means that queries that apply :sort or :filter to them will tend to be more efficient than queries with sorting or filtering after some other kind of manipulation of the results (example: doing search:count will be more efficient than search:group by:count)Using advanced filters can slow queries down - An underlying principle is that if a filter (or sort) can be done "on the database", it will be faster than a filter (or sort) that Bubble has to do after retrieving an initial set of data from the database. Which filters are done on the database vs. not? Filters which show up in the Search palette (the additional sidebar which slides out when you click "Do a search for") are done on the database and are thus are generally fast. Filters which are applied with :filter are generally "advanced" filters that are generally slower.Chained queries run in series, not in parallel - With Bubble it's possible to use the results of one search as the constraints of another search, and so on. These searches run in series, not in parallel, so if the first search returns a lot of data, that will slow the second search down, and so onBubble already does a lot of performance optimization - Bubble tries to run queries on the database, resize images on the server, tell the browser to cache Javascript, etc. as appropriate. If you're running a query that feels relatively simple and retrieves a relatively small amount of data that's running very slowly, check if there is some optimization that can be done to the app's data hierarchy or queries, based on some of the guidance hereIn general, the simpler way to express a query is faster - Not always true but a good rule of thumb. Bubble is constantly working on database optimizations for the most common patternsAvoid modifying data on every page load - Changing element states is more performant than making additional database calls to accomplish the same behaviorTry moving expensive calculations to behind-the-scenes scheduled workflows - A scheduled workflow can run the heavy query then save the result somewhere to use later; this is more performant than running the heavy query on a page loadUse the "Make changes to a list of X" workflow action cautiously - This action is great when making a quick change to a short list of things, but as the number in the list grows, it quickly raises the risk of the workflow timing out. If you're experiencing timeouts with this action, consider instead "Schedule API Workflow on a list", which is more performant because it takes the list and schedules an API Workflow to run on each item of the list, separately (i.e. lowering the risk of a timeout)Watch out! Your Bubble app's database is very flexible and powerful. It can store a lot - but if you try to store too much data in one field, it can lead to performance issues relating to that field. For example, if you have a Blog data type with a field for Contents, this should be able to handle blog posts just fine. But, if you try to stuff all the contents from Wikipedia into that one field, it probably will not work as well! More realistically, if you try to store a base64-encoded image (which is a lot of text) in a text field, this can lead to slower performance and unexpected behavior.What happens on page load?Here is a rough sequence of events of what happens when Bubble loads a page:1.Bubble sends the code for all the elements (visible and invisible)2.Bubble draws all the visible elements on the page3.Bubble fetches all the dynamic data needed for the visible elementsThis means:Invisible elements aren't drawn until they get displayed later......unless a visible item refers to an invisible item's data source. (Note that using one visible element to cover another visible one does not make the latter one "invisible" in this context!)For page load speed, the number of elements is a bigger factor than the type of elementsAll the element types are fairly similar to each other in terms of performance, with two exceptions:1.Repeating groups load different amounts of data depending on the Layout Style property; notes on performance of the different choices are in the Reference. Note also that the more elements there are in each cell of the repeating group, the more time it takes to render the page1.A repeating group with 10 cells each with 2 elements is faster than 20 separate elements, but slower than 3 elements2.A nested repeating group has a multiplicative effect on the number of elements!2.Plugins have their code included on each page load regardless if it's used. This isn't as big a performance impact because Bubble won't render the plugin if it's not used, but in general, it's a good idea to uninstall plugins that the app isn't usingWorking with soft limitsHard vs soft limitsBefore we look at how different limitations might affect your project, we'd like to briefly cover the concept of hard and soft limits:Soft limits are flexible boundaries that can be exceeded in but may impact performance or stability. Soft limits are influenced by factors such as the structure of your application and your pricing plan. For instance, a large volume of database records with substantial data can result in slower search performance.Hard limits are fixed boundaries that cannot be exceeded. Some hard limits can be increased by upgrading to higher pricing plans, and others can be circumvented through thoughtful app design and optimization, but as a developer you should be aware of them and how they might affect your project.You can read more about hard limits in our dedicated article on the subject:Article: Bubble's hard limits​TimeoutsTimeouts can happen when a specific action takes too long to complete and is terminated by the system. They are used to prevent a single request or app from monopolizing server resources, to make sure that all applications on our shared servers remain responsive and performant.Predicting and planning for limitationsAs with any database system, slowdowns, timeouts and errors when applying pressure on the Bubble server can be challenging to predict and plan for and depend a great deal on how your app is designed and the volume of data you are working on.Timeouts are rare, but can be challenging to predict and can lead to data loss and other consequences as a result of a process being terminated before it has finished.While we can document the hard limits you might encounter, soft limits are more complex as they can vary greatly depending on what your app is doing. To minimize the risk of slowdowns and  timeouts, we recommend you break up complex processes into smaller chunks.Throttling and how it may affect timeoutsIf your app spends its near-maximum allotted capacity for some time (closing in one one minute), your app may be throttled to keep it running without exceeding capacity. This can lead to a negative feedback loop where workflows are slowed down and exceed their hard timeout limit as a result. Therefore, timeouts may appear to be unpredictable, as a process may complete successfully on one occasion but time out on another.We recommend thinking holistically about your app's total capacity and keep in mind that simultaneous process can affect each other. If you can, try to move heavy processes to times when your app is less active (for example at times where you have fewer active users)Known soft limitsSVG image sizeSVG images are stored in XML code which is parsed by your browser to render a vector-based graphic that can be scaled up or down without losing resolution. This is different from raster images, such as JPEG or PNG files, that can become pixelated when scaled beyond their original size.This makes SVG files very useful in many situations, but we recommend a soft limit of 1 Mb for SVG files to avoid the local device slowing down when processing the file.Searches with the :advanced constraintSearches that use the :advanced operator can be more taxing on the server. While there's not a hard limit on what you can search through, we generally don't recommend using this constraint on more than 10,000 things.Additional notes about performanceThe power of reuse:If a page has the same search in more than one place, Bubble will automatically combine them to run the query onceLeveraging Styles helps improve performanceThe first few times you run a particularly heavy search might be a bit slower than future runs, because after Bubble sees a heavy query run a few times, Bubble builds an index that should massively speed up the search in the future (building the index could take up to an hour or so)X vs Y:An action that changes a dozen fields is more efficient than a dozen actions that change one fieldChanging a list of things is fast for relatively small lists, but for bigger lists, an API workflow will be more scalable since it doesn't run the risk of timing out the workflowWhen changing a (large) list, recursively calling an API workflow for subsequent items on the list is more scalable, though a bit slower, than running the API workflow on the entire list at onceNavigating to a new page via a link element is generally a little bit faster, because workflow actions that navigate will wait on other workflows to save data before changing the pageFor situations where data type A has connections to multiple Bs (e.g. posts having categories but only one category per post; A = category, B = post), having a field on B that references the A it belongs to is generally better. Having a field on A that lists out all the Bs that belong to it is not going to work as well when that list can get very longFor API workflows, the number of items the workflow has to act upon is a bigger impact on performance than the size of each itemCapacityIn non-technical terms, "capacity" measures how much "stuff" your app can do in a given period of time. A user coming to your website uses a bit of capacity; having hordes of users coming to your website uses much more capacity. Calling the database uses capacity; performing lots of heavy database queries uses much more capacity. Running certain workflows (the ones that happen on the server) uses capacity, and similarly calling an app's APIs uses capacity.Throughout Bubble, there are references to "units" of capacity. A "unit" is a weighted measure of different scarce resources that Bubble's systems use; it includes factors like server CPU time, database CPU time, other backend systems, and more. The exact formula for a "unit" will change over time as Bubble adds, removes or improves backend systems; one of Bubble's goals is to improve the amount of user-facing performance that a unit of capacity delivers.On certain Bubble pricing tiers (namely Free and Personal), the app will have "Basic" server capacity, which means it's sharing the same computing resources with all other Bubble apps of these tiers. When an app is upgraded to the "Professional" and "Production" tiers, the app gets dedicated or "reserved" units of capacity which are reserved for that app. When capacity is exceeded, the app is rate-limited; again in non-technical terms, it means the app won't be able to do as much "stuff" in a given period of time, and users' requests on the app will effectively be slowed down. Thus, having more capacity generally means that the app can do more "stuff" if a lot of "stuff" is going on.There's a slight twist to this. Capacity can be compared to how many checkout lines there are at a grocery store. If the store adds more lines, it can handle more customers checking out at the same time. But, if a customer comes along with a cart of hundreds of items, that customer will still take up a whole checkout line for a while; also, having more checkout lines doesn't mean that resource-intensive customer will finish faster. Similarly, having more capacity won't make a very complex database query run that much faster - it's like that one customer checking out with a lot of items in their cart. (There is a caveat to this: if Bubble detects that a large query will eat up all of an app's capacity, Bubble will slow down that query to try to maintain a reasonable user experience for the rest of the app. Thus, in certain situations, adding capacity might make a large query run faster.)Users can see how much capacity their apps are using by going to Logs on the left-side nav. The first chart shows how much time the app has hit its maximum capacity; the second chart shows how much capacity has been used by the app relative to its maximum capacity. Further down on the page is the server capacity usage details chart, which shows the breakdown of capacity used by different parts of the app within the past 24 hours. If an app is slow and is hitting capacity limits, purchasing reserved additional capacity may help.Note: Our server logging provider, AppOptics, has limits on the metric we use for the Maximum Capacity charts. Very high-activity Bubble apps may hit this limit when trying to query the logs for a long time period (i.e. 30 days). If this happens in your app, consider setting the chart date range to a shorter duration (i.e. 7 days).What about dedicated instances?Dedicated instances can help with performance in three primary ways:1.Geography - a dedicated instance can be located geographically closer to your users, which helps with the performance of large static assets2.Heavy data operations - these can be substantially faster on a dedicated instance3.Stability - with dedicated instances you can test an app on the main Bubble cluster before upgrading the dedicated instance; this can be useful for ensuring an app's stability with a new version of Bubble, as well as eliminate the risk of a Bubble-wide outageIf you're interested in hosting your app on a Dedicated instance of Bubble and want to learn more, please contact our sales team here.In closingAt the end of the day, the above are general guidelines that are meant to provide some transparency into factors impacting performance. However, these are only guidelines; if performance is critical in a particular case for your app, try testing different approaches empirically to see what's faster!
​PreviousBulk OperationsNextHard limitsLast modified 10d agoCopy linkOn this pageGeneral principles & tips about performanceWhat happens on page load?Working with soft limitsHard vs soft limitsTimeoutsPredicting and planning for limitationsThrottling and how it may affect timeoutsKnown soft limitsSVG image sizeSearches with the :advanced constraintAdditional notes about performanceCapacityWhat about dedicated instances?In closing










Hard limits - Bubble Docs









Bubble DocsSearch⌃KBubble DocsSearch⌃KIntroductionNew? Start HereChangelogUser manualDesignDataLogicMaintenanceVersion controlDatabase maintenancePerformance and ScalingHard limitsCapacity Usage (legacy)Notes on QueriesSEOTesting and DebuggingAPI Workflow SchedulerCollaboratorsCommentingIntegrationsInfrastructure/complianceCustomizing an ApplicationMore about Bubble appsCore ReferenceBubble's InterfaceElementsWorkflowsEventsDataStylesAPIBubble-made PluginsApplication SettingsActionsAccount & MarketplaceAccount & BillingDedicated PlansBuilding PluginsBuilding TemplatesMiscellaneousThe ShowcaseMore features for your to-do appThe GlossaryPre-releaseAlpha: Bubble Plugin APIPowered By GitBookHard limitsThis article focuses on Bubble's hard limits. Hard limits are fixed boundaries that cannot be exceeded, such as the number of minutes a workflow will attempt to finish before it's terminated. Some hard limits can be increased by upgrading to higher pricing plans.For soft limits (flexible boundaries that can be exceeded in but may impact performance or stability) check out our general article on performance and scaling.Like all development frameworks and server systems, Bubble comes with its own set of capabilities and limitations. While we are working hard to make a platform that is flexible and versatile enough to reliably handle as wide a range of applications as possible, we also want to be as transparent as we can with our developer community as to what kind of limitations you might experience.This article will attempt to highlight known limitations and issues that should be taken into consideration when you are evaluating Bubble for your project.Understanding the system limitsAn app reaching Bubble’s hard limits is fairly rare, but as a developer it can still be useful to know about them to be able to recognize and debug them should they occur.They can aid in the planning and development of your app, but it’s worth nothing that  understanding and predicting how they can affect your app can be a bit more complicated. The limits offer insight into the system's absolute limits and can be valid in one-off cases, but they will be less accurate in predicting the app's performance under varying conditions and workloads.For instance, if a Do a search for times out after a maximum limit of 10 seconds, it does not imply that a search that takes 3 seconds to complete is always "safe" in all situations. For example, a 3-second search that’s happening simultaneously for a million users will still, in aggregate, become very taxing for your app. At that scale, it would be best to redesign the search to complete faster. While hard limits will kick in in rare situations, it’s also important to keep in mind the combination of everything you’ve built your app to do.Hard limits can clarify why a process has stopped due to reaching a time limit and serve as a reminder that a resource-intensive process will eventually reach its limit. However, this information must be incorporated into an overarching strategy to ensure that the app’s activity  remains at sustainable levels that allows your app to scale safely.DatabaseText fieldsA single text field saved in the database has a hard limit of 10 million characters. Keep in mind that this includes characters like spaces and BBCode/HTML formatting.Thing sizeThe total size of data stored in one thing has a hard limit of 20 MB. This refers to data stored in the thing itself, and not associated data such as files and images.Bulk operations from the data tabStarting bulk operations using the Bulk button in the data tab has a hard limit of 20,000 things. In other words, you can schedule an API worflow on a maximum of 20,000 things. It's useful to note that you may approach a soft limit with a lower count depending on other factors, such as the complexity of the workflow and the amount of data stored in the things.Deleting references to a thingSometimes when you delete a thing in the database, Bubble needs to update other records to reflect that the thing has been deleted. For example, a user might be connected to other records because they are referenced in the Created by field.This can lead to a seemingly simple operation becoming more complex and resource-demanding. If the number of referenced records exceeds 100,000 records you may start to experience that referenced records are not properly updated, and by 1,000,000 there's a significant chance that the process will lead to unexpected database errors.Storing a list of thingsStoring a list of database things on another thing (such as User's Tasks) has a hard limit of 10,000 records. Note that long lists can start to affect performance at a lower number, depending on how much data the records are holding and what kind of processing you apply. In many cases, using Do a search for instead of storing long lists will be more efficient.CSV UploadCSV files uploaded in the Bubble editor or in your app have a hard file size limit of 5GB.Design and logicWorkflow timeoutWorkflows that take more than 300 seconds (5 minutes) will time out. Note that other processes running simultaneously can lead to Bubble throttling your app to maintain stability if your app comes close to maxing out its capacity. This can sometimes lead to workflows timing out because they are slowed down.Number of elements and events/actions on a pageThere's a hard limit of 10,000 combined total of elements, events and actions on a single page.Length of URLBubble doesn't have a maximum URL lengths, but to ensure browser compatibility you should stay within 2,000 characters. We generally recommended keeping URLs as short as possible for usability and SEO purposes.URL parameters are included in the character count.IntegrationsAPI Connector responsesThere's a hard limit of 50 MB for responses to an outgoing API call made with the API Connector or a plugin. Exceeding the limit will generate an error in the logs: "response too large".Headers in API callsThe headers in API calls can have a maximum total size of 8,000 charactersKeys in API callsThe keys in an API call can have a maximum total size of 20,000 characters.Data API Concurrent requestsThe Data API handles a set number of requests depending on your plan:Starter: 15 000Growth: 25 000Team: 35 000PreviousPerformance and ScalingNextCapacity Usage (legacy)Last modified 7d agoCopy linkOn this pageUnderstanding the system limitsDatabaseText fieldsThing sizeBulk operations from the data tabDeleting references to a thingStoring a list of thingsCSV UploadDesign and logicWorkflow timeoutNumber of elements and events/actions on a pageLength of URLIntegrationsAPI Connector responsesHeaders in API callsKeys in API callsData API Concurrent requests










Notes on Queries - Bubble Docs









Bubble DocsSearch⌃KBubble DocsSearch⌃KIntroductionNew? Start HereChangelogUser manualDesignDataLogicMaintenanceVersion controlDatabase maintenancePerformance and ScalingHard limitsCapacity Usage (legacy)Notes on QueriesSEOTesting and DebuggingAPI Workflow SchedulerCollaboratorsCommentingIntegrationsInfrastructure/complianceCustomizing an ApplicationMore about Bubble appsCore ReferenceBubble's InterfaceElementsWorkflowsEventsDataStylesAPIBubble-made PluginsApplication SettingsActionsAccount & MarketplaceAccount & BillingDedicated PlansBuilding PluginsBuilding TemplatesMiscellaneousThe ShowcaseMore features for your to-do appThe GlossaryPre-releaseAlpha: Bubble Plugin APIPowered By GitBookNotes on QueriesThis page will note any special points around how database queries work. These go into some of the technical details of how databases work, but can help you debug situations where a query in your app doesn't work as expected.Stop WordsThere are certain special words known as "stop words" - these tend to be short, common words which the database will ignore when you query for them, except in the context of phrases. Some examples are "the", "I", or "do".In practice, this means that if you have a query for one of these stop words or a query involving some stop words, the results may not be fully what you expect.​Here's a list of stop words affecting Bubble app queries.Stemming"Stemming" is when databases will generalize a search query to look for other words of the same stem. For example, "test" and "testing" have the same stem, so results with the word "testing" will be found when searching for "test".Stemming matches words with semantically similar meanings, so "temp" and "temps" will match, but "temp" and "tempo" will not because they are not different tenses of the same word; similarly, "test" and "intestine" will not match.(We use PostgreSQL with Snowball)Bubble Query OptimizationWhen querying the database, we try to apply an optimization on mapping operations, which makes them faster. Consider the following two Searches that both return the same list of comma separated numbers:Search A -> "MyTypesList's count"Search B -> "MyTypesList's: item 0's count, MyTypesList's: item 1's count, MyTypesList's: item 2's count, MyTypesList's: item 3's count, MyTypesList's: item 4's count, MyTypesList's: item 5's count, MyTypesList's: item 6's count"Search A under the hood is a mapped operation and turned into a single database query at its core, which is quite performant. Search B, on the other hand, generates 7 distinct database queries that run one after another and combined after the fact. This leads to a significant performance hit and should be avoided whenever possible.PreviousCapacity Usage (legacy)NextSEOLast modified 2yr agoCopy linkOn this pageStop WordsStemmingBubble Query Optimization










SEO - Bubble Docs









Bubble DocsSearch⌃KBubble DocsSearch⌃KIntroductionNew? Start HereChangelogUser manualDesignDataLogicMaintenanceVersion controlDatabase maintenancePerformance and ScalingSEOIntroduction to SEOSEO: AppSEO: PageTesting and DebuggingAPI Workflow SchedulerCollaboratorsCommentingIntegrationsInfrastructure/complianceCustomizing an ApplicationMore about Bubble appsCore ReferenceBubble's InterfaceElementsWorkflowsEventsDataStylesAPIBubble-made PluginsApplication SettingsActionsAccount & MarketplaceAccount & BillingDedicated PlansBuilding PluginsBuilding TemplatesMiscellaneousThe ShowcaseMore features for your to-do appThe GlossaryPre-releaseAlpha: Bubble Plugin APIPowered By GitBookSEOThis section covers how to work with SEO in Bubble.SEO, or Search Engine Optimization, is the effort you put into your website or app to improve its visibility in search engine results. This is a broad field encompassing a lot of different strategies both related to technical stuff (how your page is set up) and what the page offers (the content you have).SEO is how you optimize your app to appear in search results, like in this example with the Bubble homepage.Search engines do two things; they crawl the web, going through millions of websites to try to understand what they're about. Then, as a user searches for something, they try to offer the most relevant results first.Optimizing for search engines is an on-going task that can be hard to predict the outcome of; while Bubble offers the tools to prepare your app for the technical side of SEO, getting search engine traffic still depends on many different factors, like:high-quality contentrelevant keywordsthe age of your domainthe number and quality of inbound linksease of navigationaccessibilityresponsivenessThis is not an exhaustive list, but serves to illustrate that SEO is a gradual process of continually improving a app's quality and relevance, and while checking off boxes in a list is a part of it, it's not the full picture.All that being said, the road to a site that's well optimized for SEO starts with the technical details, and we'll cover that and some introductory guidelines in this article series.Is this relevant for my app?SEO is not relevant for all apps: only those that aim to get search engine traffic. In an app where it is relevant, it's not necessarily relevant for all your pages: only those that are public and again where you want to get search engine traffic.Some of the settings in this guide also play a part in social media sharing. For example, you can add descriptions and images to pages that may appear in social media post where the link to the page is shared. If this is relevant for your app, you may want to read through these articles even if you are not counting on search engine visibility.This guide will introduce you to the key SEO features available in Bubble and help you optimize your application.SEO article seriesWe have separated this series into three articles:Introduction to SEOThis article contains general platform-agnostic advice for your SEO strategy. While it's not directly related to how Bubble works, it contains useful tips that may help you use the settings in the later articles effectively.SEO settings: AppThe app section will cover the SEO features that you apply to your entire app. This includes:The app title, site name and description (used when sharing your app in social media)The default thumbnail image (also used for social media)Robots.txtSitemapsHeader/body tags301 redirectsHosting files in the root directorySEO: AppSEO settings: PageThe page section covers the SEO that you apply to each separate page. Each page is a potential listing in the search engines that you can optimize to deliver results for the topic that page covers, whether it's a static informational page or a dynamic page such as a blog post, product or social media post.A page's SEO settings are contained with the element inspector on the page element itself, and consist of the following:Page main title (as visible in the browser tab)The page SEO title (as visible in search results)The page description (used by search engines to understand the content and sometimes shown in search results)A custom image for that page (used for social media sharing)Additional on-page SEO tools can also be added in the HTML header of each page, or by placing a HTML element on the page.SEO: PagePreviousNotes on QueriesNextIntroduction to SEOLast modified 14d agoCopy linkOn this pageIs this relevant for my app?SEO article seriesIntroduction to SEOSEO settings: AppSEO settings: Page










Introduction to SEO - Bubble Docs









Bubble DocsSearch⌃KBubble DocsSearch⌃KIntroductionNew? Start HereChangelogUser manualDesignDataLogicMaintenanceVersion controlDatabase maintenancePerformance and ScalingSEOIntroduction to SEOSEO: AppSEO: PageTesting and DebuggingAPI Workflow SchedulerCollaboratorsCommentingIntegrationsInfrastructure/complianceCustomizing an ApplicationMore about Bubble appsCore ReferenceBubble's InterfaceElementsWorkflowsEventsDataStylesAPIBubble-made PluginsApplication SettingsActionsAccount & MarketplaceAccount & BillingDedicated PlansBuilding PluginsBuilding TemplatesMiscellaneousThe ShowcaseMore features for your to-do appThe GlossaryPre-releaseAlpha: Bubble Plugin APIPowered By GitBookIntroduction to SEOThis page gives a general overview of what SEO is and some tips on how to plan your SEO effortsHow important is SEO for my app?Bubble is a flexible platform that lets you build a wide range of different applications. As such, each application's need for search engine optimization can vary greatly: for some it can be a crucial source of revenue, while for others it is irrelevant.In the first part of this article we'll go over three different categories of apps to help you determine whether SEO is relevant for your project.Closed appsIf your app is designed to be used primarily by a closed group of users, such as a project management tool for your team or an inventory management system for your warehouse, you may not need to focus on SEO at all.Since your users are already aware of your web app and will likely access it through a direct link or bookmark, you don't need to worry about attracting new users through search engines. In some cases, you may even take active steps to hide the app from search engines.Public appsif your app is designed to be used by a wider audience, such as a social media platform or a marketplace, SEO should be a top priority. When users search for keywords related to your web app on search engines like Google and Bing, you want your web app to appear at the top of the search results. If this describes your app, keep reading this article series to see how to work with Bubble's SEO tools.Mixed appsA common solution is the mixed app, where some parts are closed (such as a project management dashboard), and others are public (such as the front page that recruits new users to the software). In this case, SEO can also be an important part of your marketing strategy, but one or more your app's pages will still be hidden to search engines (which usually means they require users to be logged in to access them).SEO basicsin essence, SEO is a way to make sure that your website is visible and accessible to the people who are looking for it. Imagine yourself performing a search in one of the major search engines: in most cases you will find what you're looking for among the first few results. SEO is the effort to try to be one of those pages.How search worksPersonalized and contextualized searchesSearch algorithms have become incredibly complex since they were first invented. One of the major things to grasp with most modern search engines is that a page's position in the search ranking is not static or even the same for all users. Search engines have increasingly personalized and contextualized the results to increase relevance:Personalized means that they will build a profile of your search habits and preferences and tailor the results accordingly. For example, if you're an avid Bubbler and Google the term Bubble, you are likely to get results related to Bubble.io, whereas someone else might get a Wikipedia entry for the physics of soap bubbles in the number one spot.Contextualized means that they will also take into account different kinds of current data about you, such as the device you are using, the operating system, the geographical location of your IP address, etc. This is why if you search for Taxi from your home you could get the iMDb page for Taxi Driver, but if you perform the same search from your phone on a mobile network in New York, you may get the number to a local taxi company.The reason these two points are important to keep in mind, is that they suggest a key fact in SEO: top rankings are statistical probabilities, not static positions. In other words, your SEO efforts are a mission to increase the likelihood of being the number one result, not a linear race to a top position where everyone will see you. That's why searching for your own pages does not necessarily give you any meaningful indication as to how the page is doing: Google might simply deduce that you have a high interest in it and increase its ranking for you alone, since they likely have a history of you interacting with it in the past.Top rankings are statistical probabilities, not static positions.This is why tools like Google Analytics are useful and important, since they can give you an indication as to where the traffic to your pages comes from across potentially thousands of users, normalizing statistical outliers.KeywordsSearch is based on keywords or search terms. What this means is that any user who searches for something will provide a search term like "How to make pancakes", and the search engine will go through its index looking for pages that are relevant to that term.In the early days of search engines, they simply looked for a match: "How to make pancakes" would match "How to make pancakes", and the page named "Top 10 pancace recipes" would suffer. Today, search engines are smart enough to process queries linguistically and rephrase the question, take synonyms into account and understand the value of the content on the pages it crawls through.It used to be important to simply stuff your page with keywords, but now search engines are looking for quality content which gives users what they're looking for. This doesn't mean you should disregard keywords – they are still the bread and butter of a good SEO strategy – but you should write your content for humans to enjoy, not for bots to index.General SEO adviceNow, let's look at some general advice on how to optimize your app and pages for SEO. Keep in mind that SEO is a wide field that's constantly evolving, so in this article we will only be able to cover the basics: still, adhering to these rules of thumb will set you off to a good start on your SEO journey:1.First and foremost, focus on creating quality content
Search engine algorithms are constantly evolving, but one thing that remains consistent is the importance of valuable, informative content. Write articles, make videos, and create other content that is interesting and engaging to your target audience.2.Use keywords strategically
When choosing them, make sure they are relevant to your content and that you use them in a natural way. Overusing keywords, also known as keyword stuffing, can hurt your rankings. 3.Make sure your app is mobile-friendly
Make sure that your app is easy to navigate on mobile devices. Google even favors mobile-friendly websites in their rankings. This even includes details like font size, contrast and download size. We recommend getting to know the responsive engine to build pages that work on all screen sizes4.Use meta descriptions and title tags
Meta descriptions and title tags are snippets of text that appear in search results. They should accurately describe the content of the page and entice people to click through to your app. You edit meta description and title tags in your page's SEO settings.5.Build high-quality backlinks
Backlinks are links from other websites that point to your website. Google views backlinks as a sign of authority and relevance. However, not all backlinks are created equal. It’s important to focus on building quality backlinks from reputable websites in your industry.6.Monitor your app's analytics
Tools like Google Analytics can give you valuable insight into how people are finding and using your website. Google Analytics can be implemented using our dedicated plugin or by adding a tag in your header, and there are many other useful tools that can collect and aggregate data in different ways.7.Make your app easy to navigate
Web crawlers do two things: they crawl content, and they follow links. Make sure to link pages to each other when it makes sense, and link to your most important content from your index page – search engines consider those links important. They also use the labels of your links to understand the content it leads to. You can read more about different ways of setting up links in our navigation guide.Remember, SEO is a long-term game. It takes time to see results, so don't get discouraged if you don't see immediate improvements. The advice above is not a complete roadmap to SEO results, but keeping these points in mind while you develop your app can help you make informed decisions about your pagesPreviousSEONextSEO: AppLast modified 16d agoCopy linkOn this pageHow important is SEO for my app?Closed appsPublic appsMixed appsSEO basicsHow search worksGeneral SEO advice










SEO: App - Bubble Docs









Bubble DocsSearch⌃KBubble DocsSearch⌃KIntroductionNew? Start HereChangelogUser manualDesignDataLogicMaintenanceVersion controlDatabase maintenancePerformance and ScalingSEOIntroduction to SEOSEO: AppSEO: PageTesting and DebuggingAPI Workflow SchedulerCollaboratorsCommentingIntegrationsInfrastructure/complianceCustomizing an ApplicationMore about Bubble appsCore ReferenceBubble's InterfaceElementsWorkflowsEventsDataStylesAPIBubble-made PluginsApplication SettingsActionsAccount & MarketplaceAccount & BillingDedicated PlansBuilding PluginsBuilding TemplatesMiscellaneousThe ShowcaseMore features for your to-do appThe GlossaryPre-releaseAlpha: Bubble Plugin APIPowered By GitBookSEO: AppThis section covers the app-wide SEO features that Bubble offersThe technical side of SEO starts on the app level. Search engines look at your site as a collection of pages under an umbrella: your domain. The settings that you set on the app level are less about the identity of your app (with the exception of social media sharing, which we'll cover further down), and more about providing instructions to the search engines, such as:Which pages to crawl and not to crawlURLs that have been moved and should be redirected to another URL (301 redirect)To read a sitemap file​Some parts of your app's SEO settings can be fairly technical, but if you are not sure if you need them right now, then you most likely don't. We will still cover the basics of each part here.Your app's SEO settings are found under Settings - SEO/Meta tags:Sharing in social mediaThese settings apply to social media specifically – they do not affect how your page looks in most search engines. This is done on the page level, where the index page is considered the parent of all other pages. The first part of your app's SEO settings are the social media details. This lets you set an identity for your app that social media sites such as LinkedIn, Twitter and Facebook will use when a link to your app is shared.In the example below from LinkedIn, you can see how as soon as a link is typed into a post, LinkedIn fetches the metadata.This helps you convey a consistent brand identity across both social media and search. Remember that social media sharing can significantly influence SEO, as search engines index popularity across various platforms as a factor.SEO settingsSetting up headers (<h1>, <h2>, <h3>)The structure of your page plays a role in determining its ranking. A well-structured page involves organizing your text content into distinct sections, each separated by headers at various levels (such as "<h1> and "<h2>").By default, the setting to add a tag to a text element is not available, but you can enable it by checking Expose the type of tags for text elements.Canonical URLsImagine you have a well-researched article in your app, and for some reason, it exists in two different places with slightly different URLs. This situation can create confusion for search engines, as they struggle to determine which version should be displayed in search results.Canonical URLs are the solution to this problem. They act as a signal to search engines, specifying which version of a webpage should be considered the "primary" or "preferred" one. By using a canonical URL, you help search engines avoid indexing multiple versions of the same content, thereby improving your website's search ranking and overall visibility.The setting Point URLs to primary domain for better SEO enables a Bubble-defined canonical url tag.Robots.txtSometimes, you will want to instruct search engines to not crawl specific pages in your app. For example, if your app has a front-facing index page with other pages like about and privacypolicy you will want those indexed, but you may not want to index backend or admin pages.Robots.txt (see example) is a small file that Bubble automatically places in the root directory of your app. It contains instructions to search engine crawlers, specifying which parts of the app they are allowed to access and which parts they should avoid.By default the development version of your app isn't indexed.Keep in mind that robots.txt is a request to search engines to avoid crawling certain pages. While most search engines will respect this, it doesn't actually stop them from crawling. So this is considered an SEO setting – not a security setting.How do I instruct search engines to hide a page?Let's say that you want to hide the two pages dashboard and admin from crawlers. You use the Disallow command in robots.txt along with the page name to do so:User-agent: *Disallow: /dashboardDisallow: /adminSitemapsWeb crawlers work by following links. If they discover your app's domain and its front page, and this page links to a page called about, then the crawler will also index that page.But what if a page isn't linked to? Or if a page contains dynamic content (such as www.myapp.com/products/running-shoes) – you may link to the product page, but not to every product in your inventory – which is probably the part you want to index.Keep in mind that for pages with dynamic content, each thing counts as its own separate page, even if they are all loaded on the same page.Sitemaps are like blueprints for your app that help search engines navigate and understand your app's structure more efficiently. They are essentially XML files that list all the pages within your app even if they are not linked to. Bubble can automatically generate a sitemap for all your pages, and for dynamic pages we will include the things in your database that matches the data type specified on the page.You can select which pages you want to include in the sitemap. When you check the Expose a sitemap file box, a list of your pages is displayed. Check each page that you want to include.Custom header and body contentAll the script and meta tags placed in the header will be inserted between the <head> tags on every page of your app, while the scripts added to the body field will be positioned between the <body> tags across all pages.Adding data to this field will add it to all pages – you can also add it to pages one-by-one in the settings for each page. 301 redirectsA 301 redirect is a permanent redirection method that helps maintain SEO performance when a page moves to a new location. It simple says:The page used to be here... and now it's here... and it's permanent (301)Bubble offers an easy way to add a before and after URL. The URLs should be the full URL (including the protocol such as https):❌ www.bubble.io/page✅ https://www.bubble.io/pageSEO ramifications of 301 redirectsFrom an SEO perspective, this is important for a few reasons:It helps the search engine find the new page when the old one is missingIt tells the search engine that the content on the new page is not duplicated – it has simply movedIt ensures that any referral traffic still reaches the right contentWhen are 301 redirects useful?301 redirects is useful in any case where you need to instruct search engines that a page has moved.Whenever you rename a pageWhenever you change the slug of a thing you are using as dynamic page contentIf you are moving from a non-Bubble framework and your URL structure or domain changesHosting files in root directoryBubble lets you upload files to the root directory. There are many use cases for this, but from an SEO perspective the most common use is to upload a custom sitemap .xml file.SEO audit criteriaChrome features an integrated SEO audit tool (found in Inspector > Audits). This tool highlights criteria that may impact your search results.Below is an overview of each criterion and how Bubble apps fare:Audit criteriaTextMobile-friendlyUse the responsive engine and set up pages that follow mobile best practices<meta name="viewport"> tagBubble handles this automaticallyTitleSet up titles on all pages and remember dynamic contentMeta descriptionSet up descriptions on all pages and remember dynamic contentHTTP status codeBubble handles this automaticallyLinks have descriptive textSet up all your links with descriptive textsPage isn’t blocked from indexingBubble handles this automatically"robots.txt is validBubble handles this automatically, but you can also customize it​Image elements have [alt] attributesAdd alt tags to all images in the property editor of each imageDocument has a valid hreflangBubble handles this automaticallyDocument has a valid rel=canonicalBubble handles this automatically, but you can also set up 301 redirects ​Document uses legible font sizesFont sizes less than 12px are too small to be legible. Use it sparingly (60% of text above bigger than 12px)Document avoids pluginsThis does not apply to Bubble (plugins here does not refer to Bubble plugins)PreviousIntroduction to SEONextSEO: PageLast modified 14d agoCopy linkOn this pageSharing in social mediaSEO settingsSetting up headers (<h1>, <h2>, <h3>)Canonical URLsRobots.txtSitemapsCustom header and body content301 redirectsHosting files in root directorySEO audit criteria










SEO: Page - Bubble Docs









Bubble DocsSearch⌃KBubble DocsSearch⌃KIntroductionNew? Start HereChangelogUser manualDesignDataLogicMaintenanceVersion controlDatabase maintenancePerformance and ScalingSEOIntroduction to SEOSEO: AppSEO: PageTesting and DebuggingAPI Workflow SchedulerCollaboratorsCommentingIntegrationsInfrastructure/complianceCustomizing an ApplicationMore about Bubble appsCore ReferenceBubble's InterfaceElementsWorkflowsEventsDataStylesAPIBubble-made PluginsApplication SettingsActionsAccount & MarketplaceAccount & BillingDedicated PlansBuilding PluginsBuilding TemplatesMiscellaneousThe ShowcaseMore features for your to-do appThe GlossaryPre-releaseAlpha: Bubble Plugin APIPowered By GitBookSEO: PageThis section covers the SEO settings for the page and how they can affect your rankingsFrom an SEO perspective, the pages in your app consist of three important data areas:The URL, or the web address your page tells both your users and search engines what the page is about. Metadata is data "about" the page: its title, description and social media images.Content is the actual information on your page – the design, text, images and videos that both your users and search engines seeLet's explore each of these areas.The URLThe URL is a part of the HTTP protocol – a big part of how the internet works. If you want to learn more about the technical side of how the HTTP protocol works, you can check out the article section below:Article section: The HTTP protocol (advanced)The URL is the humanly readable "address" of the page. It's used by search engines to isolate content: for example, one page in your app may be about sports shoes and another about horses: they would both have a unique URL and can show up differently in search results. URLs serve a function both for search engines and your users; they are the humanly readable way to access the page, and as such should be clear and understandable.For example, compare the URLs below:❌ https://www.my-bubble-application.com/mcakos/najsdnf✅ https://www.my-bubble-application.com/product/runnning-shoesThe first one is not easy to decipher, but the last one gives an easily understandable indication of what the page is about. Can I set up page folders?Bubble doesn't use page folders in the traditional sense, but instead relies on dynamic pages. These are pages where the content is dynamically generated from database data, and it can be used to set up unique pages for each database thing. Read more about this in the section below.Dynamic pagesEvery page lets you set a type of content. This tells Bubble what kind of data you want to load onto the page and it's how you set up dynamic pages with unique URLs.Let's say that you have an eCommerce store. On a page called products you want to dynamically show different products from your database. The data type is called Product.In the example above, we've set the Type of content to the Product data type. This means Bubble is ready to accept a Product thing that we'll pass through the URL. There are two ways in which Bubble will recognize a page thing in the URL:The thing's unique ID​The thing's slug​The unique ID is automatically created whenever a database thing is created, and as such, that field is never empty. The slug on the other hand, can be left empty and can be added or modified as needed. Let's say we have a Baseball cap product in our database – we could give that the slug baseball-cap to give that product its own unique URL:https/www.my-bubble-application/product/baseball-capThis is a nice, humanly readable URL that makes it clear to your users what the page is all about. But search engines see this in the same way: while you only have one page (product), search engines considers the slug a page on its own. Using the slug, you can set up just one page, but potentially hundreds, thousands or even millions of unique URLs that each contain unique content.For example, if your eCommerce was selling sports goods, every product in your inventory would get its own unique URL and could be found in search engines. Instead of searching for your app, new customers would find your site by searching for things like baseball caps and golf equipment.What happens if the slug is empty?If you leave the slug field empty, Bubble defaults to using the things Unique ID instead. Selecting a value the Backup field for URL will instruct Bubble to use another field as a backup in case the slug field is empty (in this case the name) – but there's a caveat: since the URL needs to be unique (and the name field does not), Bubble will append the unique ID to a web-friendly version of the name. The result might look something like this:https://my-bubble-application.com/product/product-1-1676895473036x923438355480530400So if you want readable, SEO-friendly URLs, we recommend making sure the slug field is never empty.Changing URLsAlso keep in mind that URLs that keep changing will need to be re-indexed by search engines, and they might consider it new – or even duplicate – content, which hurts your ranking. It's best to employ a strategy where you keep your URLs as consistent as possible:Once set, don't change the slug field on a database thingDon't change the names of your pagesKeep in mind that these are not absolute rules, but rather guidelines to incorporate within your overall SEO strategy. Sometimes, changes are needed, and that's fine.If you decide to change the URL of a page (page name or thing's slug), you can inform search engines that the content has moved by using a 301 redirection.Article section: 301 redirects​MetadataMetadata is a data about the page. It's not necessarily visible on the page itself, but is part of the page's code and helps search engines understand what the page is about. Information contained within a page's metadata is also often visible in the preview that search engines provide of a given page in the result.You can think of metadata then serving two purposes:One is to "convince" the search engine that your page is a relevant result for a given search by including relevant keywordsThe second is to make potential visitors want to click your page instead of another page in those same search resultsSo while you should have the search engine robots in mind when setting up your metadata, you should also keep in mind that in the end, your potential readers are human beings that will also judge the quality of your page in terms of its title, description and structure.Here's how the title and description Bubble's main page looks in the desktop and mobile version of a Google search.Optimally, all your pages should have unique metadata, so that search engines and users  understand the difference between them and they don't end up competing with each other.Metadata is a wide field of different ways you can standardize data to communicate to search engines what your page is about, but the most common fields consist of the following:Page TitleThe page title is short representation of your page's content. It's usually displayed prominently in search engine results and it's visible to your user's in the browser tab. When crafting a page title, ensure it is descriptive, relevant, and includes your target keywords.SEO TitleThe SEO title is an optimized version of your page title, specifically tailored for search engines. It is often the first line of text that appears in search engine results and should be engaging and relevant to your content. To maximize its effectiveness, keep it under 60 characters and incorporate the primary keywords for this page.DescriptionThe description, or meta description, is a brief summary of your webpage's content that often appears beneath the SEO title in search engine results. This snippet should be informative, captivating, and entice users to click on your link. Aim for a length of 150-160 characters and include relevant keywords.Search engines such as Google sometimes choose to display other content from the page in the search results instead of the description if it thinks its more relevant; as such, the description is still used by the crawler to understand the content, but it's not always visible in the search results.Social Media ImageThe social media image is the visual representation of your content when it's shared on social platforms like Facebook and Twitter. Select an image that accurately represents your content and is visually appealing and keep in mind that posts that include an image will take up more space on a social media wall, which can lead to a higher click-through rate.Page HTML Header and HTML elementsThe page HTML header can contain various tags and information that help search engines understand and index your content.These tags include:additional meta tagsOpen Graph tagsstructured datacanonical tagslanguage tagsUsing the HTML header for SEO purposes is among the more advanced strategies and is outside the scope of this guide, but there are many tutorials and Youtube videos available that go in-depth on this topic.Metadata in the page bodySome metadata (such as Schema.org Microdata and JSON-LD (JavaScript Object Notation for Linked Data) can also be placed in the body of your page, which gives access to a broader set of data sources. You can do this by placing an HTML element on the page. This is getting into fairly advanced SEO territory, and is outside the scope of this article.Metadata settings in BubbleFirst, keep in mind that there are separate app settings and page settings. The metadata we discuss in this article relates to the page, and can be different on every page in your app. They can also contain dynamic content, as we'll explore later in the article.Accessing a page's metadataSince the metadata we want to work with is stored in a page basis, we first need to navigate to the page that we want to work with in the Bubble editor. Use the page navigator to open the page.The settings are found in the element inspector of the page itself. You can access this by double-clicking the page in the editor, or clicking the name of the page at the top of the element tree (such as page index).All the metadata for the page can be edited on the Each of the fields can be filled with static content, or you can populate it with dynamic content from the data on the page.Populating metadata with dynamic contentThe metadata fields accept dynamic content from the following data sources:​Current User​​Current page thing​​Do a search for​​Get an option​​Arbitrary text​​Get data from page URL​​App text​​Arbitrary date/time​In addition, it accepts static text values so that you can give any page the title and description you want without referencing any data sources.ContentAs we explored in our Introduction to SEO, the content of your page remains one of the most important parts of your SEO. Generally, the rule of thumb is as simple as it is challenging: the content should be high-quality.While it's outside of the scope of this guide to try to determine what quality content is, there are still guidelines that can help you gain a higher ranking.DesignThe design of the page matters from a SEO perspective too: while search engines may not care whether your app looks good per se, it cares that it's accessible:Organize your app with a logical structure and provide clear, easy-to-use navigation menusEnsure good contrast between page elements like text and background to improve readability. For instance, dark grey text on a light grey background may be challenging for visually impaired usersSize and distribute elements in a way that makes it easy for all users to interact with them. For example two buttons that are too small or placed too closely together can make navigation difficultAdd alt text to your images: this not only tells search engines what the images are, but it helps visually impaired users understand your content and shows a text if the image doesn't loadUse descriptive link texts: search engines look at the label of a link when they try to understand what the link is about. Instead of just using the name of the page you are linking to, you can use the opportunity to describe it from another angle. For example, a page with the title SEO tutorial could have a link that says Learn SEO basics.TextThe easiest way for a search engine to understand the content of the page is to scan its text for keywords. Write for people, not for botsUse keywords in a natural way: keywords are the corner stone of your content; it's basically what the user wants to find. You should use keywords in your text content repeatedly, but not in an exaggerated way (known as keyword stuffing). Make the text useful and enjoyable, and make sure to mention keywords where it makes sense.Use headers: Headers (such as <h1>, <h2>, etc) is how search engines understand your pages structure. Split your text into sections and use a clear and structured hierarchy. You can enable tags for text elements by going to Settings - SEO / metatags and checking Expose the type of tags for text elements.Link pages together: when relevant, place links within your text to other pages in your app or even to external pages. MediaMix media on your pages where possible. Use a mix of text, images and video to make it as useful a page for your users as possible. Keep in mind that some types of media can increase the download size of your page.Page loadSearch engines also consider two more factors when evaluating your content:Total page download size: A lightweight page can achieve better rankings, as it is considered more user-friendly, particularly for mobile devices. The things that typically add to its total size is large images, fonts, external Javascript files (sometimes added by plugins). In essence, the less stuff you add to a page, the lighter it is.Total page load time: The time it takes from the page is opened until the content is finished rendering on the screen is also an important factor in your ranking. Avoid placing heavy, complex searches and workflows on page load, and reduce the page's total size to optimize it for fast loading.Bubble has a base loading time on all pages that we are continually working to optimize.​PreviousSEO: AppNextTesting and DebuggingLast modified 14d agoCopy linkOn this pageThe URLDynamic pagesMetadataPage TitleSEO TitleDescriptionSocial Media ImagePage HTML Header and HTML elementsMetadata settings in BubbleAccessing a page's metadataPopulating metadata with dynamic contentContentDesignTextMediaPage load










API Workflow Scheduler - Bubble Docs









Bubble DocsSearch⌃KBubble DocsSearch⌃KIntroductionNew? Start HereChangelogUser manualDesignDataLogicMaintenanceVersion controlDatabase maintenancePerformance and ScalingSEOTesting and DebuggingAPI Workflow SchedulerCollaboratorsCommentingIntegrationsInfrastructure/complianceCustomizing an ApplicationMore about Bubble appsCore ReferenceBubble's InterfaceElementsWorkflowsEventsDataStylesAPIBubble-made PluginsApplication SettingsActionsAccount & MarketplaceAccount & BillingDedicated PlansBuilding PluginsBuilding TemplatesMiscellaneousThe ShowcaseMore features for your to-do appThe GlossaryPre-releaseAlpha: Bubble Plugin APIPowered By GitBookAPI Workflow SchedulerThis section covers the Scheduler, which lets you view, pause and delete upcoming scheduled workflowsA scheduled workflow (known as an API Workflow) is a workflow that is scheduled to run on the Bubble server at a specific time. In the Logs tab of your application editor, you can access the Scheduler to view all upcoming scheduled workflows.The Live and Development environments in your app have separate schedules. If you don't see workflows that you expected to be in the list, check that you are looking at the right environment.How scheduled workflows are queuedThe scheduler is a queue, and can be imagined as a funnel. If a funnel is filled with water faster than the rate at which it drains, it will be congested and it will affect its flow. Similarly, if the scheduler is "filled" with a lot of simultaneous or very shortly spaced workflows, the scheduler can be "congested", leading to delays.Avoiding delaysTo avoid delays when working with scheduled workflows, follow the recommendations below:The more heavy the workload of the workflow, the more server capacity it will use. This is both affected by the number of actions in the workflow, and the complexity of those workflowsDatabase operations that work on a large volume of data (searches (especially with advanced filters) and actions that work on a list of things are particularly taxingA high number of actions, and in particular if they depend on each other (such as using result of step X) can also slow things downIf you are scheduling a big number of workflows (by use of Schedule API Workflow on a list or recursively), it helps to consider spacing them out with some time in-between each cycle. How much time depends on the complexity of the workflow and how much capacity your app has in generalIf the process does not need to finish at the highest possible speed, you can experiment setting a delay time of several seconds to control the capacity.Overall, server-side workflow are a very powerful feature, but you may find that you need to experiment a bit to learn how to build workflows that don't overwhelm the system.Navigating scheduled workflowsTo search for scheduled workflows, set a time in the datetime input and click Show. Bubble will search for all workflows that are scheduled after the time you have specified. Note that the search can take a little bit of time to finish.The columns let you see the details for that specific workflow:Scheduled time is the datetime when the workflow is scheduled to run. It will show in the timezone reported by your browser (meaning it may look different to you and the user who scheduled it if you are not in the same timezone).ID is the ID of the scheduled workflow. Every workflow that is scheduled has a unique ID used to identify that workflow. API Event is the event of the workflow, recognized by the label you have given it in the Workflow editor.Current user is the email of the user that scheduled the workflowParameters include any custom parameters that were provided when the workflow was scheduled​​Pause Tasks Be careful when using the Pause tasks feature, as this will stop all API Workflows from running; if you are working in the Live environment and have live users scheduling API workflows, they will not run until Pause tasks has been deactivated.If you are experiencing workflows not running as expected, check this setting.​Click here to pause upcoming workflows. If they are already on pause, this will read “Resume tasks,” which you can click in order for scheduled workflows to run again.Cancel all You can delete all past workflows that have not run yet, or scheduled workflows in their entirety. FAQ: API Workflow schedulerDoes the scheduler show external API requests?No, since workflow API requests that come from an external app are not scheduled but triggered immediately, they will not show up in the scheduler.PreviousSupported browsersNextCollaboratorsLast modified 14d agoCopy linkOn this pageHow scheduled workflows are queuedAvoiding delaysNavigating scheduled workflowsPause Tasks Cancel all FAQ: API Workflow scheduler










Collaborators - Bubble Docs









Bubble DocsSearch⌃KBubble DocsSearch⌃KIntroductionNew? Start HereChangelogUser manualDesignDataLogicMaintenanceVersion controlDatabase maintenancePerformance and ScalingSEOTesting and DebuggingAPI Workflow SchedulerCollaboratorsCommentingIntegrationsInfrastructure/complianceCustomizing an ApplicationMore about Bubble appsCore ReferenceBubble's InterfaceElementsWorkflowsEventsDataStylesAPIBubble-made PluginsApplication SettingsActionsAccount & MarketplaceAccount & BillingDedicated PlansBuilding PluginsBuilding TemplatesMiscellaneousThe ShowcaseMore features for your to-do appThe GlossaryPre-releaseAlpha: Bubble Plugin APIPowered By GitBookCollaboratorsThis section covers collaboration, which is how you invite other Bubble users to edit your application and its dataBubble makes it easy to add more editors to your app to speed up development and work on multiple features at the same time.As the app owner, you can decide who to invite to work on the app and control the level of access they have. This article will explore how to manage your team efficiently while maintaining the security of your app and its data.Collaboration features are available on Bubble's higher-tier plans.See and compare the different Bubble plans here.Our Academy quick tip on how to add collaboratorsWhat are collaborators?Every editor that you add to your app is known as a collaborator. They are connected to an app, and not to your account, meaning that if you have multiple Bubble projects, you can choose which one(s) to add one or more collaborators to. The user account that is paying for the Bubble app is known as the app owner.Collaborators need to have a registered Bubble account before they are invited.Inviting collaboratorsAdding collaborators is done in a few easy steps_1.First, make sure that the person you are inviting has a Bubble account. If not, they can sign up here.2.Navigate to Settings - Collaboration.3.Under Invite a user, provide their email address and click Invite.Controlling access levelsEach user you invite (plus your own account) makes up one row as exemplified below, meaning you set the access level of each individual user.AdminSelecting the admin checkbox grants the most extensive set of privileges, just below the owner level. Admins can invite and edit the rights of users, and all other privileges will be set to their most generous level. Admins can also change the general settings of your app.AppView onlyView and editThis setting determines whether the collaborator can make edits to your application or just view it. It does not affect the collaborators access to the database.DataThis setting determines the access a user has to your database.No permission - (cannot see or edit any database data in Development or Live)View only - (can only view data, but cannot change it in the database editor)View and run as (can only view data, but can also use the run as feature)View and edit (can view and freely edit data)LogsNo accessView and queryThis setting determines the collaborator's access to the Logs section in the Bubble editor. Keep in mind that logs can give access to see data from the database and to scheduled workflows.Only DevelopmentIf this is checked, the collaborator can only access the app and database of your Development environment.Removing a collaboratorTo remove a collaborator, simply click remove in the row of the collaborator you want to remove.Transferring an appIf you want to transfer an app completely to a collaborator, they will become the app's owner and your own role will be reduced to an admin. Keen in mind then that the collaborator can edit your rights as they see fit.Multi-user editingIf more than one user modifies an app at the same time, you will see the mouse of the other users, which helps prevent two users from modifying the same elements at the same time. You can toggle this setting with the Show the cursor of other editors when they modify the application checkbox at the bottom of the page.General advice when working with collaboratorsThe first thing to emphasize about the collaboration feature is that you are potentially granting another Bubble users a very wide access to both your app and its data. While this feature can be very powerful and indeed encourage collaboration, it should be used with care.Keep in mind the following as you start inviting collaborators:Don't give broader access than what's needed: This is advice that applies to computer security: don't give any user access to more than they need to do their job.Remove collaborators when their job is done: If the collaborator is working on the app for a limited amount of time, remove them from the list. Keep in mind, they can be added back any time you need them.Consider closing access to the Live app: granting access to Development is usually enough to develop new features and fix bugs. This also lets you stay in control of what's deployed to Live.Consider your user's privacy: Only give access to the database if it's necessary – especially the Live database. This helps you ensure that your user's data remains secure. if you need to debug with Live data, you can also consider transferring data (all of it or only the needed data) with the Copy and restore database feature.PreviousAPI Workflow SchedulerNextCommentingLast modified 1mo agoCopy linkOn this pageWhat are collaborators?Inviting collaboratorsControlling access levelsAdminAppDataLogsOnly DevelopmentRemoving a collaboratorTransferring an appMulti-user editingGeneral advice when working with collaborators










Pricing and workload - Bubble Docs









Bubble DocsSearch⌃KBubble DocsSearch⌃KIntroductionNew? Start HereChangelogUser manualDesignDataLogicMaintenanceIntegrationsInfrastructure/complianceCustomizing an ApplicationMore about Bubble appsCore ReferenceBubble's InterfaceElementsWorkflowsEventsDataStylesAPIBubble-made PluginsApplication SettingsActionsAccount & MarketplaceAccount & BillingPricing and workloadWhat contributes to workload?Using App MetricsPlans and billingFAQ: Pricing and WorkloadPlans & Billing (legacy)Account ManagementBuilding Apps for OthersSelling on the MarketplaceDedicated PlansBuilding PluginsBuilding TemplatesMiscellaneousThe ShowcaseMore features for your to-do appThe GlossaryPre-releaseAlpha: Bubble Plugin APIPowered By GitBookPricing and workloadThis section covers Bubble's pricing plans and how workload usage is calculatedIn this article, we will explore how Bubble's pricing works and help you understand the concept of workload. Bubble’s vision from day one is to make software development available to everyone, regardless of their ability to code. You’re starting the businesses of tomorrow on Bubble today, and it’s our responsibility to ensure we're able to grow alongside you and give you a framework that offers the features that you need and a platform that remains stable, secure, and high-performing.The development and launch of a new product is an important milestone for any company, and that’s why we offer a generous Free plan that lets you build and test your product. When it’s time to launch, our Starter plan is designed to be affordable so you can grow your user base and gain traction.This is why our pricing is designed around plans based on stage and maturity of your business and what features you need as you grow. Plans also come with workload bundled in, so you don’t have to worry about purchasing additional workload until your app is scaling. Essentially, workload is a measurement of how much work Bubble does to run your app, which means we can ensure that you only pay for what you need. As your app grows in users, workflows, payments, page loads and other areas, you can scale the resources needed to match your app's evolving requirements.In this article series, we’ll explore how the workload metric works and how our reporting tools provide insights into your app’s current and historical usage, so you can make informed decisions about development and scaling.PlansBubble pricing structure is separated into different plans, ranging from the free plan to a customized enterprise plan. Each plan is designed to be relevant to different stages of your app’s life cycle and offers increasingly powerful tools to aid in collaboration, data processing, log retention and backups.Each plan is connected to one application, meaning that you can easily work on multiple projects that are in different stages of development. You can choose to pay monthly or annually, and switch between the two at any time, as well as upgrade, downgrade, or cancel your app plan at any time.You can see our new pricing plans in our recent announcement and you can calculate the most cost-effective way to add more workload units using our Subscription planner.Workload unitsEach plan includes a number of monthly workload units. In essence, workload is a measure of the work that Bubble does in order to power your application. Each time your app is tasked with processing an action – such as loading a page and querying your database – it contributes to your monthly workload consumption.For example, as a user interacts with your app - opening it, navigating through it, and performing various tasks - a number of different things could take place:The app may need to retrieve data from a database to display on the screenIt may need to run some workflows to complete the user's request and createAdditional web requests might be made to third-party APIs to fetch or send dataThe server may need to process payments or authenticate user login credentialsImages, videos, and other media may need to be uploadedThere are 12 different activity types that together make up the amount of work performed by Bubble to keep your app running. We track the total workload your app consumes over the course of one month, and then reset the count for each new month. Because every app is unique, workload is a use-case agnostic metric that enables you to scale your app based on actual consumption.What is workload?Workload is a measurement of 12 different activity types that together make up the total amount of work performed by Bubble to keep your app running. To learn more about each of these activity types and how you can track them, check out our dedicated article below.

Article: What contributes to workload?​Workload tiersMost apps can operate just fine on the workload units included in their plan, but if your app requires more workload than what is included in the Starter, Growth, or Team plan, you can purchase a workload tier to add additional units.Workload tiers are usually not necessary until your app is launched to the public. For instance, a workload tier may become necessary when you begin to grow your user base, work on larger volumes of data running and/or frequently communicating with external APIs.This way:Workload tiers are offered with volume discount, meaning you can lock in a number of units at low cost.There’s no need to upgrade your plan – for example, you could stay on the Starter plan if you don’t need any of the advanced features on the Growth or Team plans, and at the same time, you could add a workload tier to scale your app.OveragesIn addition to pre-purchasing workload, we allow apps to accrue flexible overages so that your app stays available if it exceeds its monthly workload allotment. Flexible overages are charged at a  unit price applied to each additional 1000 workload units needed to cover the extra work required.This way:You only pay for the actual consumptionYour app can handle overages with no delays or outagesThere’s no need to upgrade your plan for spikes in workload. You can make an informed decision about upgrading when the time is right.Flexible overages can be enabled and disabled at any time. To disable flexible overages, go to Settings - App plan and uncheck Enable overages.Overage notificationsYou will receive an email notification when your app has reached 75% of its available workload units, to give you ample time to evaluate your options, including upgrading your plan, buying a workload tier, or enabling or disabling flexible overages.You will also receive an email notification when your app has reached 100% and overages will kick in.Add-onsRegardless of its plan, you can also add add-ons that add functionality or extra resources to your app. PluginsPlugins extend the functionality of your app by providing features and elements that go beyond Bubble’s core capabilities. Plugins can add new elements, actions, data sources and API connections and are made both by Bubble and by independent developers. Here's a breakdown of how plugins are priced:Free: Many plugins are offered for freeMonthly subscription: some plugins require a monthly subscriptionOne-time payment: some plugins require a one-time paymentNumerous paid plugins offer the option to pay a monthly subscription or a one-time payment. Note that certain plugins may rely on external API services that may incur additional costs beyond Bubble's pricing structure.You can check out Bubble's plugin store in the link below:​Plugin store​File storageAll plans include an amount of file storage space. However, if your app requires more than what is included in the plan, you can purchase additional storage.Storage costs are $3 per month for 100 GB.Measuring workloadTo help you understand and analyze workload, we provide analytics tools that give you insights into the various processes and activities that contribute.Bubble's workload charts provide reports that offer a view of your app's total monthly workload, as well as the ability to drill into individual processes, down to specific searches, workflows, API requests and expressions.While Bubble has you covered with flexible overages when heavy processing is needed, the best user experience and most cost-efficient operation will always come from building with performance in mind. We encourage you to use our workload reporting tools actively while designing and maintaining your app to identify areas for improvement.How to use the App Metrics dashboard: To learn more about how to use the App Metrics to drill down into your app’s workload activities, check out the article below:

Article: Using App Metrics​Account & Marketplace - PreviousAccount & BillingNextWhat contributes to workload?Last modified 10d agoCopy linkOn this pagePlansWorkload unitsWorkload tiersOveragesAdd-onsMeasuring workload










What contributes to workload? - Bubble Docs









Bubble DocsSearch⌃KBubble DocsSearch⌃KIntroductionNew? Start HereChangelogUser manualDesignDataLogicMaintenanceIntegrationsInfrastructure/complianceCustomizing an ApplicationMore about Bubble appsCore ReferenceBubble's InterfaceElementsWorkflowsEventsDataStylesAPIBubble-made PluginsApplication SettingsActionsAccount & MarketplaceAccount & BillingPricing and workloadWhat contributes to workload?Using App MetricsPlans and billingFAQ: Pricing and WorkloadPlans & Billing (legacy)Account ManagementBuilding Apps for OthersSelling on the MarketplaceDedicated PlansBuilding PluginsBuilding TemplatesMiscellaneousThe ShowcaseMore features for your to-do appThe GlossaryPre-releaseAlpha: Bubble Plugin APIPowered By GitBookWhat contributes to workload?This section covers how different activity types contribute to your app's total workloadWorkload, in essence, measures the work that Bubble performs to power your application. As your app processes actions such as loading a page or querying your database, it contributes to your monthly workload consumption.We track a total of 12 different activity types that each contribute to the total workload of the current month. We track the total work that occurs during each month, and reset the count at the beginning of each new month. Since every app is unique, this approach ensures a use-case agnostic way that lets you scale your app based on actual consumption.Each of the activity types below contribute to your app’s total monthly workload. You can gain deeper insight into some of these metrics by exploring your app's workload charts and identify the areas of your app that are doing the most work and take steps to optimize their performance.Activity typesEach of the activity types and how they can be explored in the App Metrics dashboard is listed in the table below. Click each activity type to learn more about it.Activity typeApp Metrics drill-down​Scheduled API Workflows​Click to view list of Workflows, click workflow name to go to that workflow in the workflow tab​Database Trigger Workflows​Click to view list of Workflows, click workflow name to go to that workflow in the workflow tab​Recurring Workflows​Click to view list of Workflows, click workflow name to go to that workflow in the workflow tab​Workflow​Click to view list of Workflows, click workflow name to go to that workflow in the workflow tab​File Uploads​No drill-down​Page Load​Click to view list of Pages, click page name will take you to that page​Outbound API calls​Click to view the list of API calls, prefixed by Workflow and Data.​Inbound API calls​Click to view list of API names:

Workflow API: name of the API Workflow
Data API: name of the data type​Data Exports​No drill-down​CSV Imports​Click to view names of CSV Files​App Editor - Run bulk​No drill-downFetching Data
∟ Real-time Search​Click to view list of searches, clicking will take you to expression in editor∟ Aggregate Search​Click to view list of searches, clicking will take you to expression in editor∟ Individual Data Request​Click to view list of searches, clicking will take you to expression in editor∟ Group by Search​Click to view list of searches, clicking will take you to expression in editor∟ Search​Click to view list of searches, clicking will take you to expression in editor∟ Autobinding​Click to view list of searches, clicking will take you to expression in editor
What does an activity cost in WU?The below table represents the cost of the raw ingredients for an action. In other words, the ultimate cost of an action can be different than the table indicates, depending on what that activity does. For example, performing a database search has the base cost reflected in the table, but that cost can vary depending on the complexity of the search and the amount of data to search through and return.As a result, if the actual workload consumption doesn't match your expectations, we recommend using your app metrics to isolate the activities that consume the most workload and look at ways to make it more efficient.

Checking specific workload units consumed in the logsUsing the Server logs tab, you can check the workload charged for each action, as well as the total for each workflow. Drilling down using the App metrics dashboardIn many cases, workload consumption can be isolated to a select few of your app’s processes that are either workload-intensive or triggered frequently. To help you identify what pages and  activities in your app are consuming the most workload, you can use the App Metrics dashboard to get an overview.The App metrics dashboard gives an overview and a detailed view of your app's workload and what contributes to it.There, you can see the total aggregated workload usage for the last 30 days, broken down by Development and Live consumption. Both Development and Live contribute to your total usage.To learn more about how to use app metrics to drill down into your app’s workload activities, check out the article below or try our interactive walk-through:Article: Using App metrics
Interactive walk-through: Exploring Workload Usage​In the same dashboard, you can also see a pie chart visualization of which activities contributed the most to workflow usage in the selected period. You can use the bar chart to select the time period to include in the pie chart visualization. By clicking on a sector in the pie chart, you can drill down to see where in your app this is occurring, down to individual pages, workflows, elements and expressions.PreviousPricing and workloadNextUsing App MetricsLast modified 27d agoCopy linkOn this pageActivity types
What does an activity cost in WU?Checking specific workload units consumed in the logsDrilling down using the App metrics dashboard










Using App Metrics - Bubble Docs









Bubble DocsSearch⌃KBubble DocsSearch⌃KIntroductionNew? Start HereChangelogUser manualDesignDataLogicMaintenanceIntegrationsInfrastructure/complianceCustomizing an ApplicationMore about Bubble appsCore ReferenceBubble's InterfaceElementsWorkflowsEventsDataStylesAPIBubble-made PluginsApplication SettingsActionsAccount & MarketplaceAccount & BillingPricing and workloadWhat contributes to workload?Using App MetricsPlans and billingFAQ: Pricing and WorkloadPlans & Billing (legacy)Account ManagementBuilding Apps for OthersSelling on the MarketplaceDedicated PlansBuilding PluginsBuilding TemplatesMiscellaneousThe ShowcaseMore features for your to-do appThe GlossaryPre-releaseAlpha: Bubble Plugin APIPowered By GitBookUsing App MetricsThis section covers how to use App metrics to analyze how different activities contribute to your app's total workload over a given period of timeYou can think of workload as the sum of all the work performed by a variety of activity types.The App metrics dashboard gives an overview and a detailed view of your app's workload and what contributes to it.The App Metrics dashboard gives you several visualizations of the work that your app is doing. The charts serve two purposes:To give you an overview of your app’s total workloadTo give you an easy way to drill down into each activity and get a granular view of how single workflows and expressions contributeWe are working on expanding the current App metrics to be able to drill down on even more granular data, as well as increasing its performance.Total workloadThe bar graph helps you get a transparent view of how much app your work is doing in total, and at what times. This visualization lets you see trends and patterns in your app's workload usage over time, which can help you plan and make more informed decisions about future upgrades or changes to your app.The total workload usage chart breaks your total workload into days and hours.Each column in the bar graph represents one day, going back 30 days from the current date by default. This example above is from a complex app that processes thousands of users, searches and workflows.Changing the time frameTo drill down into an individual day, simply click that day in the chart. Let’s look at March 20th when the workload was a bit higher:Clicking on a day zooms the chart in on that day and presents the hourly consumption.Here we can see that something happened at 10:00 am that added more to the workload of that day than the rest: this lets you zoom in more closely in time and get an understanding of what exactly happened between 10:00 am and 11:00 am that gave Bubble more work to do.The App metrics will reflect the time zone of the device that is accessing them.Isolating the timeframe extends down to the granular pie chart below, which lets you identify activity types on the top level and drill down into individual workflows and expressions to see what they are doing.Granular viewThe granular view gives you a pie chart where each slice represents one of the activity types that we track. This way, you get an understanding of the types of processes that contribute the most.Let’s look at an example:The granular pie chart presents a list of the activities that contribute the most in total. Clicking in the chart zooms in on that activity type.In the chart above we can see clearly that three activities make up the majority of the work that this app performs:Fetching dataWorkflowsData trigger workflowsThis data alone can already tell us something about how the app is built: fetching data (which relates to searches and other ways that information is being fetched from the database) makes up a large bulk of the workload consumed. A large part is also made up of workflows; this activity type covers workflows that happen on the page. Thirdly, we can see that database trigger event workflows consume about 10% of the total capacity. We can see that percentage by hovering over the sector in the pie chart.Drilling downClicking on each of these activity types provides an even more detailed view of individual instances of that activity type, and how much each one contributes to its total. Let’s click on the Workflow sector to dig deeper:Hovering one of the sectors in the pie chart shows you the percentage that particular workflow contributed in the selected time frame.Now we are down to a list of individual workflows. In this example, the workflows have generic names to illustrate, but in your app the names will reflect the labels you have provided in the workflow editor.The example shown above uses generic names to provide an illustration, but in your app, the names will reflect the labels you have given in the workflow editor.By again hovering the mouse over the top workflow, we can see that one Make changes to a thing workflow alone makes up more than 15% of the total workload in the Workflow activity type.One more click on that sector in the chart takes us directly to the workflow and action where the work is done.Clicking in a vector in the pie chart takes us directly to the workflow in the workflow tab.This way of continually drilling down in the chart can teach us a lot about where the work happens and where we can potentially make adjustments to make the app more efficient.This not only helps you keep your app operating at a cost-effective level, but it can also speed up processes to improve the overall experience for users.Excluding detailsAs you research your app’s workload, it can sometimes be useful to see what the chart looks like if we exclude some information. For example, if you want to stop focusing on workflows, you can hide that information in the chart by clicking on that activity type in the right-hand list.Let’s hide the Workflow activity type to focus on the others:As you can see, when we click on the Workflows entry in the list, it becomes crossed out, and the chart is updated to exclude it: the dark blue slice is no longer visible.Checking specific workload units consumed in the logsUsing the Server logs tab, you can check the workload charged for each action, as well as the total for each workflow. Using the dataCreating efficient applications is a process of continuous improvement. Using the App Metrics dashboard is an effective method for recognizing the processes that have the greatest impact on your app’s workload. As you analyze your workload data, you will discover that some activities are essential for your app to operate, while others can be optimized.The flexibility of Bubble’s platform opens up to different ways of solving the same problem, and sometimes small changes can lead to great improvements in efficiency.

PreviousWhat contributes to workload?NextPlans and billingLast modified 27d agoCopy linkOn this pageTotal workloadGranular viewChecking specific workload units consumed in the logsUsing the data










Plans and billing - Bubble Docs









Bubble DocsSearch⌃KBubble DocsSearch⌃KIntroductionNew? Start HereChangelogUser manualDesignDataLogicMaintenanceIntegrationsInfrastructure/complianceCustomizing an ApplicationMore about Bubble appsCore ReferenceBubble's InterfaceElementsWorkflowsEventsDataStylesAPIBubble-made PluginsApplication SettingsActionsAccount & MarketplaceAccount & BillingPricing and workloadWhat contributes to workload?Using App MetricsPlans and billingFAQ: Pricing and WorkloadPlans & Billing (legacy)Account ManagementBuilding Apps for OthersSelling on the MarketplaceDedicated PlansBuilding PluginsBuilding TemplatesMiscellaneousThe ShowcaseMore features for your to-do appThe GlossaryPre-releaseAlpha: Bubble Plugin APIPowered By GitBookPlans and billingThis section covers how to manage your plan, workloads, payments and invoicesNote: https://bubble.io/pricing is the authoritative source about pricing information, in the event of discrepancies with the documentation.Managing your planYou can subscribe to a paid plan and manage the plan that you are on in the Settings - App plan.Bubble's pricing structure comprises various plans, from the free tier to customized enterprise solutions. Each plan caters to different stages of your app's life cycle, providing progressively advanced tools for collaboration, data processing, log retention, and backups.Each plan is connected to a single application, allowing you to work on multiple projects at different development stages. You have the option to pay monthly or annually, and you can switch between the two whenever you like.Modifying a planYou can change your plan at any time during the period. When switching between paid plans, the features of the new plan become instantly available, and the cost is prorated. A credit for the unused days from the previous plan will be automatically applied to your Bubble account, and you'll be charged for the corresponding days on the new plan.Both of these calculations – remaining time and unused time – will appear on your next Bubble invoice.Canceling a planTo cancel a plan, simply downgrade it to the Free tier. Be mindful of the features associated with each plan to ensure you understand the adjustments that come with the change. In particular, if you have set up a custom domain, downgrading to the Free tier will result in losing the connection with that domain.Transferring a planWhen multiple users have admin privileges on an app, any of them can assume responsibility for the app's plan payments. If a transfer takes place, the new paying user's card will be charged at the end of the current billing period.The person you are transferring the app to must be a registered Bubble user prior to the transfer taking place.To transfer an app:1.Go to Settings - Collaboration2.Under Invite a user, type in the email of the user you want to transfer to3.Click the Transfer buttonAdditional workloadYou can read more about the difference between Workload tiers and overages in our main pricing article. You can also use our Subscription planner calculator to estimate the best option for you.Article: Pricing plans​Page: Subscription planner​Workload tiersIf your app needs more workload than the current plan provides, you can purchase a workload tier for additional units.OveragesIn addition to pre-purchasing workload, we offer flexible overages, ensuring your app remains accessible even if it surpasses its monthly workload allotment. Flexible overages are charged at a unit price for each additional workload unit.Flexible overages can be enabled or disabled at any time. To disable them, navigate to Settings - App plan and uncheck Enable overages.PaymentPayment methodsBubble accepts major credit and debit cards (see Stripe's information for more details)VisaMasterCardAmerican ExpressJCBDiscoverDiners ClubInvoicesYou can find your invoices in the Account Page, where you also have the option to define your business name and address. If you update your business name or address, you can download an updated version of your invoices reflecting these changes.You can also opt to have invoices emailed to your registered email address. Check Email every invoice to enable this.Declined paymentsBubble relies on an external service, Stripe, to process credit card transactions. A declined charge can result from the interaction between Stripe and your bank's fraud system. Even with correct information and a history of successful payments, a transaction may be declined. When processing a payment, we send all the information you've entered, and the system evaluates the risk level based on this data.If your payments are being declined, double-check that all entered information is accurate. If you still encounter issues, consider contacting your banking institution to inquire about any restrictions on your card.Refund policyWe do not offer refunds. Any paid month is non-refundable and cannot be credited back to your account.DiscountsWe extend a 30% discount for students, educators, and non-profits, applicable with appropriate documentation.Please reach out to [email protected] to get this activated on your account. Discounts cannot be applied retroactively, cannot be applied to Custom plans, cannot be applied to workload tiers 3-5, and cannot be combined with other discounts such as Referral or Affiliate credits​PreviousUsing App MetricsNextFAQ: Pricing and WorkloadLast modified 10d agoCopy linkOn this pageManaging your planModifying a planCanceling a planTransferring a planAdditional workloadWorkload tiersOveragesPaymentPayment methodsInvoicesDeclined paymentsRefund policyDiscounts










FAQ: Pricing and Workload - Bubble Docs









Bubble DocsSearch⌃KBubble DocsSearch⌃KIntroductionNew? Start HereChangelogUser manualDesignDataLogicMaintenanceIntegrationsInfrastructure/complianceCustomizing an ApplicationMore about Bubble appsCore ReferenceBubble's InterfaceElementsWorkflowsEventsDataStylesAPIBubble-made PluginsApplication SettingsActionsAccount & MarketplaceAccount & BillingPricing and workloadWhat contributes to workload?Using App MetricsPlans and billingFAQ: Pricing and WorkloadPlans & Billing (legacy)Account ManagementBuilding Apps for OthersSelling on the MarketplaceDedicated PlansBuilding PluginsBuilding TemplatesMiscellaneousThe ShowcaseMore features for your to-do appThe GlossaryPre-releaseAlpha: Bubble Plugin APIPowered By GitBookFAQ: Pricing and WorkloadThis section covers frequently asked questions about workload and our pricing plansWorkload BasicsWhat is workload?Workload is a measure of the work that Bubble does in order to power your application. Whenever your app is asked to perform a task like processing a payment, communicating with an API, or searching through your database, this counts towards your monthly workload usage. More technically, workload measures all the underlying activities your app does as it runs. Activities include database operations, workflows, and web requests. For a full list of inputs, see our article on what contributes to workload.How much workload will I need?The amount of workload an app needs depends on a variety of factors. If you’re new to Bubble, the best way to assess your workload needs is to get started on a Free plan. From within your free app, you will be able to see how the activities unique to your app contribute to workload usage. The Free plan comes with more than enough workload to build any kind of app you can imagine! Most apps on a paid plan do not need more workload than the amount included in the Starter, Growth, and Team plans. If your app scales to the point where you outgrow the amount of workload on your plan, then you can subscribe to a workload tier on a monthly or annual basis. To learn more, see our workload explainer blog post.What are my options if I need more workload?If you need more workload than the amount that comes with the Starter, Growth, or Team plan, you have two options: you can purchase a workload tier for additional workload, or you can pay for overages as you go. Apps on the Free plan or Agency plan cannot subscribe to workload tiers and cannot enable overages. You can use our Subscription planner to calculate the most cost-effective way to add more workload units.What are workload overages?In a given month, your app on the Starter, Growth, or Team plan will incur overages if workload usage exceeds the amount of workload that comes bundled into your app plan plus the amount of workload that you may have purchased via a workload tier. Overages are pay-as-you-go. If you do not have a workload tier subscription, then the overage rate is $0.30 per 1,000 workload units. If you have a workload tier subscription, you can find your app’s overage rate here. Apps on the Free or Agency plan cannot incur overages because these plans are designed for development. For details on overage billing, please see our billing section.Can I cap the amount of workload my app uses?Yes, you can disable overages in the App Plan tab so that your application does not use more than the amount that comes with your app plan plus any additional workload you may have purchased via a workload tier. If your app hits the workload limit while overages are disabled, you will receive an email notification that your app has been taken offline. You can bring your app back online if you enable overages or purchase a workload tier. If you keep overages disabled, then your app will go live again at the start of your next billing period.Workload DetailsWhat is the relationship between workload and speed?Workload is a measure of the work that Bubble does to power your application over the month. There is no direct relationship between workload and speed. However, apps that were previously throttled by capacity will experience significant improvements in speed after switching to the new pricing plans.What is the relationship between user count and workload?The more users who use your app the more activities your app is performing, which means your app will consume more workload. The size of your user base is a factor, but it is not necessarily the main driver of workload usage. For example, your application could have a small number of users but run a lot of activities in the background throughout the month. Whenever Bubble is doing work to power your application, workload usage goes up. The load of each activity is just as important as the quantity of activities.What is the relationship between workflow runs and workload?The more workflows your app runs, the more workload your app will consume. The amount of workload it takes to run a workflow can vary significantly depending on how many steps are in the workflow and what actions the workflow is performing. Thus, the number of workflow runs is a factor, but it is not necessarily the main driver of workload usage. For example, your application could have a small number of workflow runs that each consume a lot of workload. Or your application could have a large number of workflow runs that each consume very little workload. The load of each workflow is just as important as the quantity of workflows run. To learn more, see our blog post on workload.What is the difference between Live vs. Development workload?All paid apps have 100,000 monthly workload units for their Development environment included in their plan.Live workload comes from your end users interacting with the Live version of your application. Development workload comes from app editors interacting with your Development environment. Common sources of Development workload include activities like testing your app and cleaning your database. Live and Development workload both contribute to your total workload usage.  Does using the editor consume workload?The only activity in the editor that uses workload is running bulk operations and importing/exporting data in the Data tab. Otherwise, interacting with the editor does not contribute to workload usage.What are ways I can optimize and reduce my app’s workload usage?You can view workload charts in the Logs tab of the editor to see your app’s workload usage over time and to drill into the activities that are contributing to workload usage. To learn more, see our article on how to use the workload charts.BillingDo I need a plan for each project?You can have as many projects as you’d like, and each project has its own plan.When do I get billed? When is my billing period?You will get billed on a monthly or annual basis for your app plan. Your billing period starts on the day you sign up for your subscription. If you purchase a workload tier, your initial charge will be prorated based on the same billing period as your app plan. If workload overages are enabled on your app, you will get billed for any additional workload units your app consumes above the limit in the previous calendar month.How does overage billing work?If your app plan is on a monthly billing cycle, then any overages that your app incurs in the previous calendar month will get included in your monthly bill. If your app plan is on an annual billing cycle, then you will get billed at the start of each month for the previous calendar month’s overages.Will I get notified before I’m charged for overages?Yes, you will receive an email notification when your app has reached 75% of its available workload units. You will also receive an email notification when your app has reached 100% and overages will kick in.Can I upgrade, downgrade, or cancel my app plan at any time?Yes, you can make changes to your subscription in the App Plan tab.Can I switch between monthly and annual billing at any time?You can switch from monthly to annual billing at any time.Can I subscribe to an annual subscription for my app plan and a monthly subscription for my app’s workload tier?No, your app plan and workload tier must be on the same billing cadence.What are add-ons that I can purchase separate from what comes in the plans?Workload tiers (only available to apps on the Starter, Growth, or Team plans), additional file storage for $3 per 100 GB, and plugin subscriptions.CapacityWhat happened to server capacity? Will it still be different across the new plans?All apps across all the new pricing plans will operate at the highest capacity that Bubble can offer while maintaining the integrity of our own infrastructure. Apps that were previously throttled by capacity will experience significant improvements in speed after switching to the new plans.How does server capacity translate to workload?There is no direct conversion from server capacity to workload. Capacity is like a speed limit on the highway, whereas workload is the distance traveled. On legacy pricing plans based on capacity, apps get throttled when they exceed the capacity limit. On the new pricing plans, we avoid throttling apps and instead measure monthly workload, the aggregate amount of work Bubble does to power your app in a given month. There are no limitations to the amount of workload your app can consume unless you choose to disable overages.PreviousPlans and billingNextPlans & Billing (legacy)Last modified 29d agoCopy linkOn this pageWorkload BasicsWhat is workload?How much workload will I need?What are my options if I need more workload?What are workload overages?Can I cap the amount of workload my app uses?Workload DetailsWhat is the relationship between workload and speed?What is the relationship between user count and workload?What is the relationship between workflow runs and workload?What is the difference between Live vs. Development workload? Does using the editor consume workload?What are ways I can optimize and reduce my app’s workload usage?BillingDo I need a plan for each project?When do I get billed? When is my billing period?How does overage billing work?Will I get notified before I’m charged for overages?Can I upgrade, downgrade, or cancel my app plan at any time?Can I switch between monthly and annual billing at any time?Can I subscribe to an annual subscription for my app plan and a monthly subscription for my app’s workload tier?What are add-ons that I can purchase separate from what comes in the plans?CapacityWhat happened to server capacity? Will it still be different across the new plans?How does server capacity translate to workload?










Benefits of Dedicated - Bubble Docs









Bubble DocsSearch⌃KBubble DocsSearch⌃KIntroductionNew? Start HereChangelogUser manualDesignDataLogicMaintenanceIntegrationsInfrastructure/complianceCustomizing an ApplicationMore about Bubble appsCore ReferenceBubble's InterfaceElementsWorkflowsEventsDataStylesAPIBubble-made PluginsApplication SettingsActionsAccount & MarketplaceAccount & BillingDedicated PlansBenefits of DedicatedUsing DedicatedBuilding PluginsBuilding TemplatesMiscellaneousThe ShowcaseMore features for your to-do appThe GlossaryPre-releaseAlpha: Bubble Plugin APIPowered By GitBookBenefits of DedicatedIf you're interested in hosting your app on a Dedicated instance of Bubble and want to learn more, please contact our sales team here.Bubble offers a dedicated hosting plan, where we host your app on infrastructure isolated from other Bubble customers. Like with our shared plans, we run your app: no need for you to deal with setting up servers and installing software, or monitoring them to keep them healthy. Unlike our shared plans, however, we run your app on dedicated servers that aren’t shared with any other customers, giving you increased reliability and the ability to scale as needed.A typical dedicated installation consists of a database, a cache server, and one or more application servers. On a dedicated plan, we don’t monitor the number of workflows you run; instead, your only limit is the physical capacity of the hardware. We monitor the performance of your infrastructure, and if it looks like your app is slowing down due to more users than you have the hardware for (congratulations!), we’ll reach out to you and suggest an upgrade.

BenefitsDedicated hardware has the following benefits.Scalability. We can quickly add more capacity to your dedicated cluster to deal with increased demand.More consistent application performance. Because you aren’t sharing the hardware with other Bubble customers, the only impact on application performance is how active your users are.Greater reliability. Having your own infrastructure isolates you from the majority of Bubble-wide issues.Data isolation. Your app's data is isolated from other customers’ data, leading to a stronger security profile.Control. You decide when new Bubble code is rolled out to your cluster. Planning a major client meeting? You can wait until afterward to deploy the latest version of Bubble.Hosting region choice. Choose from our list of AWS regions: Oregon, Ireland, Frankfurt, Mumbai, Singapore, Tokyo, Seoul, Sydney, Sao Paulo, Montreal, London, Bahrain. Prices vary from region to region.SecurityWe work hard to keep your data safe. Some key points:Our dedicated infrastructure is hosted on top of Amazon Web Services, which is a world-class hosting platform with extremely high security standards.User data on a dedicated plan is stored in a dedicated AWS RDS instance. Data is encrypted at rest, and the credentials for accessing the database are controlled by an automated system that logs all access to them.Dedicated plans come with free SSL certificates to ensure that all communication with your app servers are secure. Once you have a certificate installed, we force all communication with the app to occur over https.Bubble’s privacy rules are a powerful way of implementing application-level security. They provide you with fine-grained control over which items and which fields each user on your app can see and edit. If you have questions about how to set up privacy rules to ensure that your users’ data is protected, we’re happy to help.Uptime and ReliabilityBackups and data integrityWe offer point-in-time recovery for application changes and user data. You can jump back to how your data was at any point on the timeline. It’s up to you how long we retain data for; you can scale up your data storage as needed to retain it for as long as you want. In addition, we use Amazon’s RDS automatic backups to ensure that we can recover from the total loss of a database server.UptimeBubble is new, rapidly developing technology, and we are constantly working to keep applications online. We monitor dedicated infrastructure 24 / 7, and respond as fast as possible to outages. We plan on offering uptime SLAs as technology matures.Dedicated plans offer two uptime advantages over shared hosting. The first is that, since your app is isolated from other customers, issues with another customer’s app can’t spill over to affect your app. The second is that we deploy new code to our shared hosting environment before deploying it to dedicated clusters, so you are less likely to be impacted by new bugs as we add features and extend the Bubble platform.Finally, for customers who are especially concerned with uptime, we offer high-availability dedicated configurations. This means we have spare servers constantly running that can be swapped in if something goes wrong with a primary server. In terms of greatest impact, having the database server as high-availability is most important, followed by the cache cluster, followed by the application server.ConfigurationHow big your infrastructure needs to be depends on a lot of factors, including how your app works, the number of users you have, and the way those users interact with the app. We will conduct a needs-analysis with your team to determine the configuration that you need, which will also be based on our experience maintaining infrastructure for other Dedicated users. Our team will manage changes to your infrastructure for you. Account & Marketplace - PreviousDedicated PlansNextUsing DedicatedLast modified 28d agoCopy linkOn this pageBenefitsSecurityUptime and ReliabilityBackups and data integrityUptimeConfiguration










Using Dedicated - Bubble Docs









Bubble DocsSearch⌃KBubble DocsSearch⌃KIntroductionNew? Start HereChangelogUser manualDesignDataLogicMaintenanceIntegrationsInfrastructure/complianceCustomizing an ApplicationMore about Bubble appsCore ReferenceBubble's InterfaceElementsWorkflowsEventsDataStylesAPIBubble-made PluginsApplication SettingsActionsAccount & MarketplaceAccount & BillingDedicated PlansBenefits of DedicatedUsing DedicatedBuilding PluginsBuilding TemplatesMiscellaneousThe ShowcaseMore features for your to-do appThe GlossaryPre-releaseAlpha: Bubble Plugin APIPowered By GitBookUsing DedicatedOnce your Bubble Dedicated Cluster is running. Your experience with Bubble will mostly be the same, except a few things:You should still manage your account, update your credit cards, emails, etc. at bubble.io, as you would do before the upgrade. However, your app is hosted on a subdomain (dXX.bubble.is). The first time you'll visit this URL, you'll be prompted to login with your Bubble credentials. When you'll edit your app (from bubble.io/home), you'll be take directly to the right subdomain. Note: App modification date (for sorting apps in your home page) is either stored on the app object or in a Meta Thing. Since the app object cannot be read from a dedicated cluster, and the Meta thing is not updated when edits are made to a dedicated app, the app modification date is not reliably stored. Upgrading your serversYou can control the version of your installation in the Dedicated Panel visible at the top of the Editor (look for the fork icon). Clicking on it will show you if you're on the latest version or if you can upgrade. If you can upgrade, you'll be able to see what is new compared to your installation, and a button to upgrade. You can press this button and keep working (and refresh when the process is completed).Note: We highly recommend that dedicated users upgrade their servers with some regular frequency. Doing a large upgrade after a long period of not upgrading has some risk of triggering many behind-the-scenes calculations occurring at the same time. Normally, these calculations are in different versions of the Bubble codebase that are spread out over time, so they don't cause issues for the main cluster. Doing too many of these calculations at once due to a big dedicated upgrade could temporarily take up (or exceed) the available resources in the dedicated instance.Monitoring DashboardOnce you are on a Dedicated Plan, you will be able to monitor the health of your servers in the Logs Tab of the Editor. This will show you CPU utilization and memory usage. We will proactively notify you if your usage is reaching certain levels, and then we'll work with you to upgrade your infrastructure as needed. Do reach out to us as usage patterns change.Like applications on the main cluster, you also have access to Server Logs per application. Server logs are accessible for 2 weeks on Dedicated plans. PreviousBenefits of DedicatedNext - Account & MarketplaceBuilding PluginsLast modified 1yr agoCopy linkOn this pageUpgrading your serversMonitoring Dashboard










Alpha: Bubble Plugin API - Bubble Docs












Bubble DocsSearch⌃KBubble DocsSearch⌃KIntroductionNew? Start HereChangelogUser manualDesignDataLogicMaintenanceIntegrationsInfrastructure/complianceCustomizing an ApplicationMore about Bubble appsCore ReferenceBubble's InterfaceElementsWorkflowsEventsDataStylesAPIBubble-made PluginsApplication SettingsActionsAccount & MarketplaceAccount & BillingDedicated PlansBuilding PluginsBuilding TemplatesMiscellaneousThe ShowcaseMore features for your to-do appThe GlossaryPre-releaseAlpha: Bubble Plugin APIPowered By GitBookAlpha: Bubble Plugin APIThis documentation covers the updated API for server-side plugin actions to be compatible with Node 16. Node 16 removes support for the Fibers extension, which allowed the existing version of the server-side actions API to expose functions that returned results directly, rather than as Promises. Consequently, some API functions will change in a non-backwards-compatible way.If your plugin uses any server-side actions, you will have to manually update your plugin to be compatible with the updated version.This document explains in detail what the updated plugin API looks like and how to update your plugin to work with the updated plugin API. In most cases, the necessary changes will be straightforward.What's the difference between the Fibers extension and Promises?Fibers and Promises have two different approaches to handling asynchronous operations.The Fibers extension (old) lets you write asynchronous code in a more synchronous-looking way. By using Fibers, you can pause and resume the execution of your code at certain points, effectively making it appear as if the asynchronous tasks are running synchronously. This can make the code easier to read and understand, as it resembles typical synchronous code flow.Promises (new), on the other hand, are a native JavaScript feature for managing asynchronous operations. They represent the eventual completion (or failure) of an asynchronous operation and its resulting value. Promises provide a more standardized approach to handling asynchronous tasks, allowing you to chain operations, handle errors, and improve the overall structure of your code.ChangesFunction NameOld APINew APIcontext.requestcontext.requestcontext.v3.requestcontext.asynccontext.asynccontext.v3.async.get method on Bubble Things.get method.get method (returns promise).get method on Bubble Lists.get method.get method (returns promise).length method on Bubble Lists.length method.length method (returns promise)get_object_from_idget_object_from_idcontext.getThingByIdget_objects_from_idsget_objects_from_idscontext.getThingsByIdThese functions now return a promise for their original return value (see JavaScript documentation on promises). If you have a server-side action that uses any of these functions in your plugin, the action will break when you update. See below for a guide on how to fix this.Step-by-step guidePrepend async to any top-level function that calls context.request, and await just before context.request. Change context.request to context.v3.request.Also, consider switching over to using node-fetch, which has a more modern, standardized API.Prepend async to any top-level function that calls context.async, and await just before context.async. Change context.async to context.v3.async.Also, consider switching over to using util.promisify, which is a more modern syntax.Prepend async to any top-level function that calls the .get method on Bubble Things and await just before .get.Prepend async to any top-level function that calls the .get method on Bubble Lists and await just before .get.Prepend async to any top-level function that calls the .length method on Bubble Lists and await just before .length.ExamplesHere are a few examples of how to update the run_server function of your plugin’s server-side actions.context.request: Current plugin APIfunction(properties, context) { // Send a request to the cat API synchronously const response = context.request({ url: 'https://api.thecatapi.com/v1/images/search', json: true })const cat_image = response.body[0].url return { cat_image }}context.request: Updated plugin APIasync function(properties, context) { // Send a request to the cat API asynchronously, with promises const response = await context.v3.request({ url: 'https://api.thecatapi.com/v1/images/search', json: true })const cat_image = response.body[0].url return { cat_image }}.length(): Current plugin APIfunction(properties, context) { let list_length = properties.my_list.length() return { list_length }}.length(): Updated plugin APIasync function(properties, context) { let list_length = await properties.my_list.length() return { list_length }}Using node-fetch instead of context.requestHere’s an example of how to update your code using context.request to use node-fetch, based on the same starting point as the earlier context.request example.async function(properties, context) { // Use the node-fetch module to make an HTTP request const response = await fetch{'https://api.thecatapi.com/v1/images/search') const body = await response.json() const cat_image = body[0].url return { cat_image }}Using promises instead of context.asyncIn the old version of the API, plugin authors frequently had to use context.async to interoperate with modern, Promise-using JS libraries. For instance, to use the weathered npm package to fetch a list of real-time weather warnings, you might write code like this:function(properties, context) { const { Client } = require('weathered')const client = new Client() const region = properties.region || 'NY'  const alerts = context.async((cb) => {        client.getAlerts(true, { region }) .then((result) => cb(null, result)) .catch((error) => cb(error)) })  const weather_alerts = alerts.features.map(f => f.properties.description) return { weather_alerts }}In the new API, which is Promise-based already, you don’t need to jump through this hoop; you can await the result of the call directly.async function(properties, context) {    const { Client } = require('weathered')const client = new Client()    const region = properties.region || 'NY'     const alerts = await client.getAlerts(true, { region })     const weather_alerts = alerts.features.map(f => f.properties.description)    return { weather_alerts }}Using utils.promisify instead of context.asyncBut if the code you’re trying to wait for with context.async is callback-based rather than promise-based, you'll still need some sort of wrapper.Here’s a (somewhat contrived) example of using the callback-based fs.stat API from Node to inspect the filesystem of the lambda your action is running on:function(properties, context) { const fs = require('node:fs') const { inspect } = require('node:util') const stats = context.async((cb) => {        fs.stat('/', cb) }) return { stats: inspect(stats) }}Instead of using context.async, you could also wrap fs.stat with node’s built in promisify utility to make it return a promise, then await that promise:async function(properties, context) { const fs = require('node:fs') const { inspect, promisify } = require('node:util')  const stats = await promisify(fs.stat)('/') return { stats: inspect(stats) }}Change logHere are the changes that we will make to the plugin API:context.request is being deprecated (this means that we plan to eventually stop supporting it), moved to context.v3.request, and will now return a promise. We recommend that plugin authors use the globally-available node-fetch instead.context.async is also being deprecated, moved to context.v3.async, and will now return a promise. We recommend that plugin authors use promisify from Node’s built-in util module instead.The .get method available on Bubble Things now returns a promise.The .get method available on Bubble Lists now returns a promise.The .length method available on Bubble Lists now returns a promise.We are adding two new utility methods on Bubble Things:​id(): returns the Thing’s ID (synchronously – not as a promise).getAll(): returns a promise for an object with all fields of the Thing.Lists now also implement the AsyncIterable interface, so you can use for (await ... of ...) loop syntax to loop over the list.the single_api and list_api fields are still present, but no longer encouraged (we will also remove official documentation for these fields). In their place are two new context methods: isBubbleThing and isBubbleList.We are adding official support for two previously usable, but undocumented functions: getThingById and getThingsById. We added these functions to the context object to be more consistent with the rest of API. These functions also now return promises.See below for more detail.export type Primitive = string | number | boolean |  Date | null | undefined​/** Any value that can be passed as a property to an action or stored in the DB. */export type BubbleValue = Primitive | Primitive[] | BubbleThing | BubbleList​/** Fields present on any Bubble data type. */export interface ThingFields { // These fields are guaranteed to be present on any database Thing. 'Slug'?: string 'Created Date': Date 'Modified Date': Date​ // Other fields might also be present, depending on the data type. [_: string]: BubbleValue}​/** Additional fields present on the User data type. */export interface UserFields extends ThingFields { 'email': string 'logged_in': boolean}​/** * An object representing a single Thing from the Bubble app's database. */export interface BubbleThing { /** Returns the names of the fields on the Thing. */ listProperties(): string[]​ // CHANGED - now returns a promise /** Returns the value stored in a particular field of this Thing. */ get(propertyName: string): Promise<BubbleValue>​ // NEW /** Returns an object with all the thing's fields and their values. */ getAll(): Promise<Record<string, BubbleValue>>​ // NEW /** Returns the unique ID of this Thing. */ id(): string​ // for historical interest - maybe de-document these single_api: true list_api: false}​/** * An object representing a list of Things from the Bubble app's database. *  * As lists may be quite large, the data contained in the list isn't all * loaded up front. Therefore, methods for accessing data within the list * are generally asynchronous. */export interface BubbleList { // CHANGED - now returns a promise /** The number of items in this BubbleList. */ length(): Promise<number>​ // CHANGED - now returns a promise /** Fetch a portion of a BubbleList as an array. */ get(start: number, length: number): Promise<BubbleThing[]>​ // NEW /** Allows you to use a BubbleList with the `for (await x of list)` syntax */ [Symbol.asyncIterator](): AsyncIterator<BubbleThing>​ // for historical interest - maybe de-document these single_api: false list_api: true}​/** An object containing utility functions available to server-side actions. */export interface Context { /** The current user who initiated the workflow that's running this action. */ currentUser: BubbleThing​ /** The timezone the workflow is running in. */ userTimezone: string​ /** An object containing any keys set for this plugin in the app. */ keys: Record<string, string>​ // NEW /** Check if a JS value is a BubbleThing object. */ isBubbleThing(x: unknown): boolean​ // NEW /** Check if a JS value is a BubbleList object. */ isBubbleList(x: unknown): boolean​ // NEW - was secret global before /** Fetch a BubbleThing object for a given unique ID. */ getThingById(id: string): Promise<BubbleThing | null>​ // NEW - was secret global before /**     * Fetch the corresponding BubbleThing objects for each ID in an array.     * Results will be returned in the same order as requested, with `null`     * in place of any IDs with no corresponding Thing.     */ getThingsById(ids: string[]): Promise<Array<BubbleThing | null>>​ // NEW/CHANGED - these used to be top-level properties of the context v3: ContextDeprecatedV3}​/** Context functions that are no longer recommended, but are provided for backwards compatibility. */export interface ContextDeprecatedV3 { // CHANGED - now returns a promise /**     * See documentation for the `request` library.     *      * @deprecated We recommend you use node-fetch instead.     */ request(...args: unknown[]): Promise<unknown>​ // CHANGED - now returns a promise /**     * Takes a node-style asynchronous function which expects to be passed a callback,     * and turns it into a promise.     *      * @deprecated We recommend you use node's built-in `util.promisify`.     */ 'async': <T>(fn: (callback: (err: unknown, res?: T) => void) => void) => Promise<T>}​declare global { /** Exposes node-fetch to plugins. */ function fetch(...args: unknown[]): Promise<unknown>}Miscellaneous - PreviousThe GlossaryLast modified 8m agoCopy linkOn this pageChangesStep-by-step guideExamplescontext.request: Current plugin APIcontext.request: Updated plugin APIUsing node-fetch instead of context.requestUsing promises instead of context.asyncUsing utils.promisify instead of context.asyncChange log










Introduction to testing and debugging - Bubble Docs









Bubble DocsSearch⌃KBubble DocsSearch⌃KIntroductionNew? Start HereChangelogUser manualDesignDataLogicMaintenanceVersion controlDatabase maintenancePerformance and ScalingSEOTesting and DebuggingIntroduction to testing and debuggingThe DebuggerThe Server LogsSupported browsersAPI Workflow SchedulerCollaboratorsCommentingIntegrationsInfrastructure/complianceCustomizing an ApplicationMore about Bubble appsCore ReferenceBubble's InterfaceElementsWorkflowsEventsDataStylesAPIBubble-made PluginsApplication SettingsActionsAccount & MarketplaceAccount & BillingDedicated PlansBuilding PluginsBuilding TemplatesMiscellaneousThe ShowcaseMore features for your to-do appThe GlossaryPre-releaseAlpha: Bubble Plugin APIPowered By GitBookIntroduction to testing and debuggingThis section covers general advice for testing and debugging your appFirst, let's spend some time to define the different terms included as you prepare your app for live users:Testing is the process of trying out the different steps of your application to check that it works as expected. It doesn't have to mean something wrong, but if there is, testing is meant to uncover it. Debugging is done when you've observed a non-expected behavior. It's the process of understanding the root cause of the issue so that you can rectify it.This introductory guide will give you some general advice on how to test and debug your app, before we move on to the tools that Bubble offers.The Development environment and Live environmentEvery Bubble app consists of two environments: Development and Live. Development is a fully functioning version of your app that you (and your team) can work in together to see exactly what the finished app will look live. Live is the app that your users see.The two environments have database that operate completely independently of each other. In other words, in the Development environments you can make changes to your database that have no effect on your live app, making it a completely safe environment to experiment in whichever way you need to.You should always aim to fully complete testing and debugging before deploying your app to Live.TestingPlan your testing and break it into piecesTesting is all about using your app as your users would, and working systematically through all pages and features to identify issues. While this guide will not outline what a systematic approach should look like (everyone works differently), we will still encourage you to be mindful of how you organize your testing.Keep notesIf you are testing something and see an issue elsewhere, take a note for later and stay focused on the task at hand. Letting your focus drift from place to place is an easy way to miss things, so remember to stick to the plan, but note down anything else you see.Add test dataAn app with no data in it and an app with lots of data can behave very differently. Adding test data can help you identify issues related to design, performance and security.Test on different screen resolutions and devicesIf your app is going to be used on different screens and devices, it's a good practice to test it on  different resolutions and maybe even throttling the connection speed and CPU. Chrome Developer tools offers a highly useful Device Mode that lets you do all of these things.Test as different usersAs you introduce privacy rules and conditions, your users will start to experience the app differently. Some users may have access to specific parts of your database and app, while others don't. In these cases it's useful to make a habit of testing your app as different users.For example, if you have two user types, user and admin, it's likely that one has a different access level than the other, and you may miss issues or inconsistencies if you only test as one of them.How to test the app as another userTo use your app as a specific user, simply search for that user in the built-in database editor and click Run as.Using the Run as feature lets you easily test your app as another user without having to know their credentials.DebuggingMake sure you can reproduce itAs you keep testing your app, you will uncover the occasional issue – don't worry, it happens even to the most experienced developers!When beginning to debug an issue, the key initial step is to establish a consistent and predictable method for reproducing it. In practice, this involves retracing your steps and running multiple tests to confirm that the issue consistently appears every time, and with the same characteristics.This lets you get a firm grasp of the problem before you spend time tackling it.Stay systematic and break it downEach issue you find may have more than one cause. As you identify it or them, stay focused on one at a time. It can be useful to find ways to test that the cause you're currently working on is fixed before moving on to the next. Again, keep notes to make sure you don't miss anything.Remember privacy rulesMany issues are related to data being unavailable because of privacy rules. Keep in mind that they apply everywhere (elements, workflows and conditions), so it's often a good idea to check the rules for the relevant data type.Collect informationIf the error has been reported by one of your users, you should try to collect as much information as you can about the circumstances that produced the error.Which user is it?What kind of device and browser are they using?Are they using ad blockers or script blockers of any kind?What were the exact steps they took to produce the issue?Can it be reliably reproduced, or could it be because of a poor connection or other external reason?Reach out to the communityBubble has an incredibly welcoming and helpful community. If you ever find yourself stuck on an issue, don't hesitate to seek help! Share your problem on the Bubble forum, reach out to our Success Team, or hire one of our expert coaches to assist you in resolving it.Take a break!Sometime issues are best solved on a walk outside, in the shower or lying on the couch. Other times you simply need some time to refresh your mind before returning to the screen and continuing the search.Your brain is a muscle – it too needs rest between the sessions!Testing & debugging toolsBubble offers two ways to debug issues, each serving a specific purpose:The debugger (checking errors on elements and in workflows as they happen)The debugger is a small panel at the bottom of the screen when you are running your app in Development. Using the debugger, you can:Run workflows action-by-action and check data (such as the result of a search) related to each stepInspect the elements on the page to check their attributes, conditions and associated dataArticle: The Debugger​The Server Logs (diagnosing past issues)The second tool for diagnosing past issues is the Server Logs. This feature allows you to retrospectively examine what occurred in your workflows and check any unexpected behavior or errors.Article: The Server Logs​​Using safe modesOur Academy quick tip on how to preview your app in safe modeSafe modes is a way to preview your app, but disabling certain parts for debugging purposes:HTML - this disables on-page HTML elementsCommunity plugins - this disables community-made pluginsIf the issue resolves itself in Safe mode, you'll know it is due to something introduced by a plugin or custom code.How to enable Safe modeYou enable Safe mode by holding the mouse button on the Preview button for one second. A dropdown will show you the list of options.What if you think it's a Bubble bug?The Bubble development team spends a lot of time on testing and uses automated tests extensively to avoid bugs. However, if you think you're hitting an issue that is not caused by the way you built your app and workflows, but a non-expected behavior of a Bubble core feature, please reach out and we'll look into this. This doesn't apply to plugins that aren't built by the Bubble Team - for these issues we recommend reaching out to the plugin author.Reporting bugs to the Bubble team should always be done via the Bug Reporting tool, that prompts you to fill out the different necessary information for the team to look into it. Before you file a bug, please do a few things to ensure this is a real bug.1.Before you submit the report, make sure your connection is fully-functional, and that you're on the latest version of your browser.2.Test the issue in Incognito mode (or 'private browsing') first, as ad blockers and browser extensions can interfere with web applications.3.Remove custom code you've added to your app in HTML elements, headers, etc.As you're filing a report, please keep a few things in mind to ensure a rapid resolution.1.Try to be as specific as possible when you describe the issue. "It doesn't work, I think it is be a bug" is not specific enough. Instead, saying "based on the condition, this element should be red, but instead I see it green" is much more actionable.2.Similarly to what was described above for your own debugging process, the more isolated the issue is, the faster we can look into it. In fact, it's best if you're able to reproduce the issue on a blank, test page, outside of the context of your design and core workflows.3.Please make sure your instructions can be understood by someone that has no knowledge about your app. The best descriptions are 'click on button A', 'type xx in the input', 'click on button B', 'see the problem'.4.Try to share screenshots, as prompted in the form.5.Videos can be useful, but shouldn't replace the written from. It should only be a complement (and is usually not necessary).We understand bugs can be frustrating and can slow down your development work. However, with the right reporting, you can help us identify issues quickly and fix them, and when the team fix an issue for you, it is fixed for the entire Community.PreviousTesting and DebuggingNextThe DebuggerLast modified 13d agoCopy linkOn this pageThe Development environment and Live environmentTestingPlan your testing and break it into piecesKeep notesAdd test dataTest on different screen resolutions and devicesTest as different usersDebuggingMake sure you can reproduce itStay systematic and break it downRemember privacy rulesCollect informationReach out to the communityTake a break!Testing & debugging toolsUsing safe modes










The Debugger - Bubble Docs









Bubble DocsSearch⌃KBubble DocsSearch⌃KIntroductionNew? Start HereChangelogUser manualDesignDataLogicMaintenanceVersion controlDatabase maintenancePerformance and ScalingSEOTesting and DebuggingIntroduction to testing and debuggingThe DebuggerThe Server LogsSupported browsersAPI Workflow SchedulerCollaboratorsCommentingIntegrationsInfrastructure/complianceCustomizing an ApplicationMore about Bubble appsCore ReferenceBubble's InterfaceElementsWorkflowsEventsDataStylesAPIBubble-made PluginsApplication SettingsActionsAccount & MarketplaceAccount & BillingDedicated PlansBuilding PluginsBuilding TemplatesMiscellaneousThe ShowcaseMore features for your to-do appThe GlossaryPre-releaseAlpha: Bubble Plugin APIPowered By GitBookThe DebuggerWhen encountering unexpected behavior, the debugger comes in handy for closely examining each step of a workflow or the details of an element as the app is being used.The debugger primarily serves two key purposes:Run workflows action-by-action and check data (such as the result of a search) related to each stepInspect the elements on the page to check their attributes, conditions and associated dataThe debugger does not have any visible parts in the Bubble editor, but is visible when you run your app in Development.Our Academy tutorial on how to use the debuggerEnabling and disabling the debuggerWhen you click Preview to see your app in run-mode, the debugger is automatically activated. If you want to enable or disable it, you simply have to change the URL parameter debug_mode. When the debugger is enabled, you will see the parameter in the URL:debug_mode=trueA full URL will look like the following:https://my-bubble-application.bubbleapps.io/version-test?debug_mode=true...or if you have multiple URL parameters:https://my-bubble-application.bubbleapps.io/version-test?parameter=key&debug_mode=trueThe debugger is only accessible in the Development environment, and adding the URL in Live will have no effect. It is meant for desktop use and is not designed to work on mobile.To disable the debugger, simply remove the parameter, or set its value to false.Using the debuggerWhen the debugger is active, you will see a bar at the bottom of the screen when you preview your app:When the debugger is active you will see it as a bar at the bottom of the screen. When the debugger is enabled, Bubble automatically adds space at the bottom of the page. This is only visible in debugging mode and not to your Live users.The left-hand side shows the different controllers for inspecting workflowsThe right-hand side shows the controls for inspecting elementsWorkflowsThe left side of the Debugger is the Workflow Debugger. You can see three buttons that control how the debugger behaves when a workflow is being triggered. Three modes are possible:1.Normal mode runs workflows without interruption.2.Slow mode runs workflows with a a one-second pause between each action3.Step-by-step' mode lets you control the execution of the workflow by pausing between each action until you click Run next (only visible when step-by-step mode is enabled)Step-by-step is the most widely used debugger mode, as it gives you complete control over each action step, allowing you to progress at your own pace.When the mode is active, Bubble will work for a workflow to be triggered by an event. As soon as that happens, it will pause on the event itself so that you can check what triggered it and any associated The first step the debugger will show is the event that triggered the workflow. In this case it was a button-click. The step we are currently inspecting is marked in grey, and the next step is in white.Clicking Run next will move on to the the next step: the Create a new Product action:Note the numbers in the screenshot above:1.In this example, we inspect the Name field of the Product we are creating, where the value "T-shirt" is displayed. By clicking the value, we can trace the data source from which it is derived.2.After clicking the value, we can see its data source on the right-hand side: in this example the value came from an input form called Input Product name.By pausing at each step and examining the details of each action, you can verify if the data yields the anticipated values and is saved as intended.The debugger status is saved when the page is refreshed. If a workflow navigates to a different page or triggers a page refresh, the resuming workflow will execute subsequent actions in the same mode.Adding breakpointsWhen working on complex pages with numerous workflows, the step-by-step mode might not be ideal since it stops too frequently. If you want to investigate a specific workflow, event, or action, you can add a breakpoint that activates the debugger in step-by-step mode when that event or action is executed.Breakpoints are added in the workflow editor, either on an event or an action. As soon as Bubble encounters that event or action, it will pause and enable step-by-step mode from that point forward.Note that this setting only has an effect when the debugger is active (meaning debug_mode=true appears in the URL) and will not influence how your application runs in Live.Inspecting elementsSometimes, you may need to determine why an element is displayed in a specific manner, particularly when using conditions or displaying data. The debugger lets you select an element on the page and view the list of conditions and fields, along with their values.First, to enable Inspect mode, click the Inspect button in the bottom right corner. There are two ways to select an element to inspect:You can click the element on the page (workflows will not trigger when you are in inspect mode)You can use the dropdown list next to the Inspect button and search for/select the element from there (this is useful for elements that are invisible).Understanding expression evaluationsWhen an element is selected, you can start to evaluate its properties, conditions and expressions. In the example below, we have selected the Create Product button.Conditions are displayed in a separate list under the header Conditions. If they are in red color, it means the condition does not return true. If the condition is true, it will be displayed in a green color.Digging into expressionsBy clicking the relevant expression, you can take a closer look at each step and how it evaluates.In the example above, we can check the last part of the expression: is logged in. We can see that this part of the expression returns a no.If we click the first part of the expression, we can see the parameters associated with the data source Current user:Any expression can be inspected in this way. Most fields on this user are empty since they are logged out, but you can see the unique ID and Created/Modified date that Bubble generates for all users who visit your app.Each expression allows you to inspect every data source, operator and comparison. Any sub-expressions are also accessible by clicking them.Run-mode execution errorsThe debugger also lets you identify run-mode execution errors, such as when an API call to a service returns an error due to a missing parameter. When a workflow or element encounters an error, the debugger icon turns red and becomes clickable.Clicking on it reveals the list of errors.When you encounter an issue, particularly when using external services through plugins, checking for execution errors in the debugger should be one of your initial troubleshooting steps.PreviousIntroduction to testing and debuggingNextThe Server LogsLast modified 10d agoCopy linkOn this pageEnabling and disabling the debuggerUsing the debuggerWorkflowsAdding breakpointsInspecting elementsUnderstanding expression evaluationsDigging into expressionsRun-mode execution errors










The Server Logs - Bubble Docs









Bubble DocsSearch⌃KBubble DocsSearch⌃KIntroductionNew? Start HereChangelogUser manualDesignDataLogicMaintenanceVersion controlDatabase maintenancePerformance and ScalingSEOTesting and DebuggingIntroduction to testing and debuggingThe DebuggerThe Server LogsSupported browsersAPI Workflow SchedulerCollaboratorsCommentingIntegrationsInfrastructure/complianceCustomizing an ApplicationMore about Bubble appsCore ReferenceBubble's InterfaceElementsWorkflowsEventsDataStylesAPIBubble-made PluginsApplication SettingsActionsAccount & MarketplaceAccount & BillingDedicated PlansBuilding PluginsBuilding TemplatesMiscellaneousThe ShowcaseMore features for your to-do appThe GlossaryPre-releaseAlpha: Bubble Plugin APIPowered By GitBookThe Server LogsThis section covers how to use the Server Logs for debugging your appWhile the Debugger lets you to test and debug the current situation, server logs enable you to explore issues in the past. This is useful both to check the results of changes that you made during testing, and for looking at what actually happened when a live user experienced an issue.Keep in mind that the server logs for Development and Live are separate. If you have created any custom branches using Version control, they are still contained within the Development and Live environments.Accessing the logsTo access the server logs, do the following:Click on the Logs tabThen the Server logs sectionSearching logsThe logs let you search for log entries with the following constraintsStart/end time lets you enter a time range for the event(s) you are looking for.User email lets you constrain the search by the user who initiated the events.Contains is a freetext field that lets you search for the workflow label to narrow it down further.More filterIn addition to the main filters above, clicking the Advanced button gives you access to an extended list of filters.Started running workflowAction condition failedAutobinding operationScheduled task completedSending email failedEvent condition passedFinished running actionPlugin server side outputHTTP requestEvent condition not passedFinished running workflowPlugin server side errorHTTP responseRunning actionWorkflow errorScheduled task to runCombined, these tools create a comprehensive toolset to refining your search and zeroing in on the issueIf you are searching through an app with a lot of activity, searching through logs can be time-consuming and potentially time out if the amount of data is too big. If you experience this, we recommend narrowing down the timeframe in which to search.Zooming in on a workflowEach workflow consists of several steps in the log: one for the event:one for the condition on the event (even if empty)one for each action step.Unless you are very specific with your constraint, most log searches will return a long list of results (especially if you are searching in an app with active users). To isolate one workflow and see all the steps logged in that workflow, you can use the Zoom on this workflow feature:Zoom on this workflow lets you isolate a workflow to make it easier to follow all the associated steps. Click image to enlarge.​The Server Logs section in the Logs tab allows searches of the log of server-side actions, such as send email or change data, executed when users interacted with the app. Search for a particular user by email or ID, within certain dates, or specific keywords.  Note that server logs depend on the version of your app, so you should make sure you are focusing on the version where the issue was reported (Live versus Development). To search logs, you need to define the starting and the ending dates of the search. Searching logs can take some time, and the Editor will display entries as they arrive. When you already see some results and scroll down, the editor will fetch more entries (and the caption of the search button will change according to the situation).If your app has a lot of traffic, you'll see a lot of logs. It is useful to narrow down the search by using some search criteria. The most common criteria you can use when searching for logs is picking the type of events you're interested in.Workflow starts: shows all initiated workflows that run on the server, whether the condition is met and the workflow is executed, or not.Passed events: shows all workflows that run after the condition evaluated to yes.Non-passed events: shows all workflows that didn't run after the condition evaluated to no. This is useful as you try to debug something that didn't happen.Actions: only shows actions, and not the events that led to this action's execution.Errors: shows server-side errors that happened when executing a workflow. For instance, a credit card failure, or a send email failure. This will be especially useful to diagnose issues.TipIf your app has a lot of activity, chances are it has a lot of logs. If you're searching through the logs and the query is slow or timing out, try narrowing the time window of your search.When you search for logs, if you have more information about the problematic workflows, you can narrow down the search even more by searching for specific users and terms. The first input lets you enter a user's email or a user's unique ID. When this is filled, the search will only return workflows started by this user.The last box lets you type a string that you want to search for. If an action has a property that evaluated to some text and if you search for this text, the workflow will be retrieved. For instance, if you know an email was sent with the text 'Boston' in it, searching for 'Boston' will return the Send Email action.Looking at the resultsAfter the results are retrieved, they will appear in descending order, with the most recent ones displayed first.For each entry, you will see the following details:1.Action/event name: this name reflects the label on the action/event of the workflow.2.User email: the email of the user who initiated the workflow. If the user isn't signed up, the field will show Anonymous user)3.User ID: the unique ID of the user who initiated the workflow.4.Message/properties: properties for this action/event, or any error message(s)Following editor linksClicking on a step in the Log takes you directly to the workflow editor for the relevant event or action in that log entry:Clicking on an event or action takes you directly to the relevant entry in the workflow editor.PreviousThe DebuggerNextSupported browsersLast modified 10d agoCopy linkOn this pageAccessing the logsSearching logsMore filterZooming in on a workflowLooking at the resultsFollowing editor links










Supported browsers - Bubble Docs









Bubble DocsSearch⌃KBubble DocsSearch⌃KIntroductionNew? Start HereChangelogUser manualDesignDataLogicMaintenanceVersion controlDatabase maintenancePerformance and ScalingSEOTesting and DebuggingIntroduction to testing and debuggingThe DebuggerThe Server LogsSupported browsersAPI Workflow SchedulerCollaboratorsCommentingIntegrationsInfrastructure/complianceCustomizing an ApplicationMore about Bubble appsCore ReferenceBubble's InterfaceElementsWorkflowsEventsDataStylesAPIBubble-made PluginsApplication SettingsActionsAccount & MarketplaceAccount & BillingDedicated PlansBuilding PluginsBuilding TemplatesMiscellaneousThe ShowcaseMore features for your to-do appThe GlossaryPre-releaseAlpha: Bubble Plugin APIPowered By GitBookSupported browsersThis section covers the browsers that are officially supported by BubbleRun-modeBubble's framework relies on web technologies that may not be compatible with all older browsers. Consequently, Bubble provides official support for specific browsers and versions. Keep in mind that this applies to apps in run-mode, meaning it affects the end-users of your Bubble app.Browser support summaryBubble officially supports Edge, Firefox, Chrome, Brave and Safari on web and mobile webWe encourage end-users to upgrade these browsers to the latest version availableWhen an end-user uses an unsupported older browser version, most parts of the app will likely still function. Browser support primarily impacts the visual display of your app, while workflows and database operations are generally unaffected.Edit-modeEdit-mode is the interface you, as a Bubble developer, interact with while building and editing your app, i.e. the Bubble editor.Bubble supports the latest version of Edge, Firefox, Chrome, Brave and Safari for edit-mode. We highly encourage Bubble users to upgrade these browsers to the latest version available.PreviousThe Server LogsNextAPI Workflow SchedulerLast modified 10d agoCopy linkOn this pageRun-modeBrowser support summaryEdit-mode










Security - Bubble Docs









Bubble DocsSearch⌃KBubble DocsSearch⌃KIntroductionNew? Start HereChangelogUser manualDesignDataLogicMaintenanceIntegrationsInfrastructure/complianceSecurityLimitations & Known IssuesCustomizing an ApplicationMore about Bubble appsCore ReferenceBubble's InterfaceElementsWorkflowsEventsDataStylesAPIBubble-made PluginsApplication SettingsActionsAccount & MarketplaceAccount & BillingDedicated PlansBuilding PluginsBuilding TemplatesMiscellaneousThe ShowcaseMore features for your to-do appThe GlossaryPre-releaseAlpha: Bubble Plugin APIPowered By GitBookSecurityBubble offers you a lot of flexibility and power - with all the building blocks Bubble provides, you can build any idea you have! But, just like if you had your idea built in code, you have to think about data security and general security of your Bubble app. Luckily, Bubble has a variety of features to help you set up the security situation you desire.It is highly recommended that you think about security as you build your app but especially before you launch your app to actual users!!There are a variety of security tips throughout the Docs, but here is a compilation of top things to keep in mind:1.(Very important!) Privacy Rules help you specify what data a given user should be allowed to see - make sure to use them!2.Be careful with how you've set up your API Connector calls - for example, always make sure that credentials go in "private" fields, and be additionally cautious if you're choosing to make an API call from the client.3.When activating your app's Data or Workflow API, be careful with how an outsider authenticates to make a call, and for the Data API, make sure Privacy Rules are set up!4.Certain aspects of how the app is built are visible to technically savvy users, including: which apps exist in an app, what data types and fields exist in an app, any static content on a page even if it's in a hidden element, all option sets (including their options and attributes) in an app, etc.In case you'd like extra help with security best practices, there are third-party tools in the Bubble ecosystem that can assess an app for any known security weaknesses, e.g. nocode:nohack.User manual - PreviousInfrastructure/complianceNextLimitations & Known IssuesLast modified 1mo agoCopy link










Limitations & Known Issues - Bubble Docs









Bubble DocsSearch⌃KBubble DocsSearch⌃KIntroductionNew? Start HereChangelogUser manualDesignDataLogicMaintenanceIntegrationsInfrastructure/complianceSecurityLimitations & Known IssuesCustomizing an ApplicationMore about Bubble appsCore ReferenceBubble's InterfaceElementsWorkflowsEventsDataStylesAPIBubble-made PluginsApplication SettingsActionsAccount & MarketplaceAccount & BillingDedicated PlansBuilding PluginsBuilding TemplatesMiscellaneousThe ShowcaseMore features for your to-do appThe GlossaryPre-releaseAlpha: Bubble Plugin APIPowered By GitBookLimitations & Known IssuesBelow are known issues you might encounter in rare cases while building your app. These bugs will be reviewed on a regular basis and removed upon resolution.GeneralDropdown elementsBecause Bubble "dropdown" elements use the native HTML "<select>" tag, you generally cannot apply styles (e.g. option alignment, border roundness, etc.) to the expanded list of options (this is a limitation with CSS in general - more info). For alternatives, consider plugins.Scroll barsScroll bars, especially when in repeating groups, can sometimes look subtly different than designed on different browsers and devices. This is because Bubble relies on the end-user's operating system and browser for how a scrollbar should look.Older HardwareWhile we try to keep the Bubble editor speedy, if you are using older hardware (e.g. mid-range laptops from before 2012 or desktops from before 2010), you may experience notable lag when using the editor.Platform / BrowserSome things are not fully supported across platform / browser configurations. These are important to note as you think about the users of your application:Android (mobile)Currency format for inputs not supportedSafari (mobile)Popups don't show until page reload or tilting deviceInput cursor is offset by few lines while typingPage behind open popup is still scrollableTwilio Plugin video chats do not work properly due to some quirks of Safari mobile that are difficult to workaround. When a call is initiated, the users on the call are only able to hear and see themselves, yet Twilio recognizes this call as a successful call. Safari 13+ Safari 13 prevents any 3rd party cookies from going to iframe requests. Because of this, if your Bubble app is running in an iframe, the bubble client will start workflows as the uid of the user that was attributed to it, but will register as no_user server-side, due to the lack of cookies. The mismatch will unfortunately prevent any workflow from running successfully.  As a workaround, set "Do not set cookies on new visitors by default" in Settings > General > Privacy & Security, so that both server and client know that this is an anonymous user.Microsoft EdgeDropping files from explorer to browser does not work as expected because of a browser compatibility issueFirefoxWe are aware that Firefox has a bug with their localStorage persistence when the browser setting "Delete cookies and site data when Firefox is closed" is enabled. The impact on Bubble apps is that some behaviors, especially ones involving cookies and iframes, may not work as expected for end users on Firefox with this setting. The most notable known source of error is with Stripe transactions, which may not redirect back to the app correctly. (This is, unfortunately, a bug at the Firefox level. We are monitoring the situation there in the hopes they will fix this soon.)Note that different browsers will have their own idiosyncrasies. While Bubble tries to ensure that Bubble app behavior is consistent across browsers, there are times when this is out of our control. For example: when an app's user clicks "back", that will usually fire the "When page is loaded" event, but Safari does not allow this behavior. This is because Safari follows a different paradigm for how "back" works relative to other browsers.Browser versions play an important role in the overall reliability of your Bubble app. Some Bubble features will break as browser versions become outdated. It is highly recommended to keep your browser updated to the latest version since browsers contain bugs that get fixed with their own subsequent updates.Some custom fonts are occasionally rendered slightly differently across different operating systems and browsers. This most commonly manifests itself in their height differences which may affect element layouts.Plugin Compatibility Because plugins are "blocks" of custom code that extend the functionality of your app, installed plugins are all compiled at the same time when your app is loaded. As a result, all of the Plugins installed in your app must be able to co-exist in the same environment. Sometimes, plugins can collide with each other and cause unexpected behavior, especially when they share similar resource names. While we strongly recommend plugin developers try their best to not overwrite some common parts of the browser code, this doesn't always happen. While these compatibility issues are hard to know in advance, we will try our best to document any known compatibility issues here until we implement a system of separating plugin code in runmode. AddToAny (Bubble) and Selectize Dropdown (3rd Party)​
​PreviousSecurityNext - User manualCustomizing an ApplicationLast modified 1mo agoCopy linkOn this pageGeneralOlder HardwarePlatform / BrowserAndroid (mobile)Safari (mobile)Safari 13+ Microsoft EdgeFirefoxPlugin Compatibility 





